<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>?</title>
    <style>
body, html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    position: fixed;
    background: #000;
}

* {
    font-family: "Comic Sans MS", 標楷體;
}

#cvs {
    position: fixed;
    top: 0;
    left: 0;
    display: block;
    z-index: 0;
    touch-action: none;
}

#banner {
    position: relative;
    z-index: 3; 
    display: flex;
    align-items: center;
    padding: 10px;
    pointer-events: auto;
    width: fit-content;
}

#banner button {
    margin-right: 10px;
    padding: 5px 12px;
    font-size: 20px;
    background: #444;
    color: #fff;
    border: none;
    outline: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.2s;
}
#banner button:disabled {
    color: #888;
}
#banner button:hover {
    background: #666;
}
#banner button.active {
    background: #1b72c2;
    color: #000;
}
#inff{
    padding: 0px 4px 4px 4px;
    border: 1.5px #00ffbf solid;
    z-index: 5;
    top: 0;
    right: 0px;
    position: fixed;
    width: 250px;
    white-space: pre;
    color: #fff;
    background: rgb(40, 40, 40);
    display: none;
}
#inf{
    z-index: 10;
    position: fixed;
    top: 5px;
    right: 4px;
}
.tt{
    color: #fff;
    font-size: 25px;
}

svg#svg2{
    fill: #a7a7a7;
    position: relative;
    top: 2.9px;
    left: -1px;
    cursor: pointer;
}
svg#svg2:hover{
    fill: #ffffff;
}
button.btn,button.btn1 {
    background: transparent;
    border: none;
    height: 30px;
    width: 30px;
    border-radius: 15px;
    outline: none;
}
button.btn:hover {
    background: #909090;
}

::-webkit-scrollbar-corner {
    background: #181818;
}

::-webkit-scrollbar-track {
    -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    background-color: #303030;
}

::-webkit-scrollbar-thumb:hover {
    background: #6c6c6c;
}

::-webkit-scrollbar-thumb {
    background-color: #a1a1a1;
    border-radius: 10px;
}

::-webkit-scrollbar {
    width: 10px;
    height: 10px;
}

::-webkit-resizer {
    background: #828282;
    outline: 2px solid #b6b6b6;
}
@media screen and (max-width: 768px) {
    #banner {
        width: 100% !important;
        flex-wrap: wrap !important; 
        gap: 5px !important;
    }

    #banner button {
        font-size: 20px !important;
        padding: 5px 10px !important;
        margin: 0 !important;
    }
}
    </style>
</head>

<body>
    <div id="banner">
        <button id="btnMove">Move</button>
        <button id="btnPoint">Point</button>
        <button id="btnLine">Line</button>
        <button id="btnCircle">Circle</button>
        <button id="btnUndo">↶ </button>
        <button id="btnRedo">↷</button>
    </div>
    <canvas id="cvs"></canvas>
    <button id="inf" class="btn1" onclick="toggleInf()" title="inf">
            <svg id="svg2" width="20px" viewBox="0 0 416.979 416.979"><path d="M356.004,61.156c-81.37-81.47-213.377-81.551-294.848-0.182c-81.47,81.371-81.552,213.379-0.181,294.85   c81.369,81.47,213.378,81.551,294.849,0.181C437.293,274.636,437.375,142.626,356.004,61.156z M237.6,340.786   c0,3.217-2.607,5.822-5.822,5.822h-46.576c-3.215,0-5.822-2.605-5.822-5.822V167.885c0-3.217,2.607-5.822,5.822-5.822h46.576   c3.215,0,5.822,2.604,5.822,5.822V340.786z M208.49,137.901c-18.618,0-33.766-15.146-33.766-33.765   c0-18.617,15.147-33.766,33.766-33.766c18.619,0,33.766,15.148,33.766,33.766C242.256,122.755,227.107,137.901,208.49,137.901z"/></svg>
        </button>
    <div id="inff" class="tt"
><b>Shortcuts</b>
1-4 : Switch Modes
Z   : Undo
Y   : Redo
Esc : Cancel
Wheel : Zoom
Mid-Click : Pan</div>
    <script>
var banner = $("#banner");
var btnMove = $("#btnMove");
var btnPoint = $("#btnPoint");
var btnLine = $("#btnLine");
var btnCircle = $("#btnCircle");
var btnUndo = $("#btnUndo");
var btnRedo = $("#btnRedo");
var inff = $("#inff");
var inf = $("#inf");
var cvs = $("#cvs");
var ctx = cvs.getContext("2d");
var ti = cvs.width / cvs.offsetWidth;
const points = [];
const lines = [];
const circles = [];
const Mode = {
    MOVE: "move",
    POINT: "point",
    LINE: "line",
    CIRCLE: "circle",
};
const PointType = Object.freeze({
    FREE: { name: "free", dof: 2 },
    ON_LINE: { name: "onLine", dof: 1 },
    ON_CIRCLE: { name: "onCircle", dof: 1 },
    INTERSECTION: { name: "intersection", dof: 0 },
    LINE_LINE: { name: "lineLine", dof: 0 },
    CIRCLE_CIRCLE: { name: "circleCircle", dof: 0 },
    LINE_CIRCLE: { name: "lineCircle", dof: 0 }
});
const camera = {
    x: 0,
    y: 0,
    scale: 1
};
const mouse = { x: 0, y: 0, show:false };
let mode = Mode.MOVE;
let draggingPoint = null; // 正在拖曳的點
let selectedPoint = null; // LINE和CIRCLE模式下的第一個點
let hoveredPoint = null; // 滑鼠懸停的點
let isPanning = false;
let panStartX = 0;
let panStartY = 0;
let infhd=1;
let lastDist = 0;
let lastTouchMid = {x: 0, y: 0};
let isMultiTouch = false;
let touchStartTime = 0;
let touchStartPos = { x: 0, y: 0 };

const history = [];
let historyIndex = -1;

const EPS = 1e-6;
const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase());
const BASE_SNAP_DIST = 13*(1+isMobile*0.3); // 吸附半徑，像素值
const dpr = window.devicePixelRatio || 1;

if(isMobile){
    inf.style.display="none";
}

function toggleInf(){
    if(infhd){
        inff.style.display="block";
    }
    else{
        inff.style.display="none";
    }
    infhd^=1;
}
function resizeCanvas() {
    const width = window.innerWidth;
    const height = window.innerHeight;

    // 1. 設定畫布內部的渲染解析度 (放大)
    cvs.width = width * dpr;
    cvs.height = height * dpr;

    // 2. 設定畫布在網頁上的顯示大小 (保持不變)
    cvs.style.width = width + 'px';
    cvs.style.height = height + 'px';

    // 3. 核心：將 Context 縮放回邏輯像素，這樣你之後的繪圖邏輯都不用改
    ctx.setTransform(1, 0, 0, 1, 0, 0); // 先重設所有轉換
    ctx.scale(dpr, dpr); 

    draw();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
cvs.addEventListener("touchstart", (e) => {
    if (e.touches.length >= 2) {
        isMultiTouch = true;
        draggingPoint = null;
        isPanning = false;

        const t1 = e.touches[0];
        const t2 = e.touches[1];
        
        // 記錄初始距離
        lastTouchDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
        
        // 記錄初始中心點
        lastTouchMid = {
            x: (t1.clientX + t2.clientX) / 2,
            y: (t1.clientY + t2.clientY) / 2
        };
    }else {
        isMultiTouch = false;
        touchStartTime = Date.now();
        touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
}, { passive: false });
cvs.addEventListener("touchmove", (e) => {
    if (e.touches.length === 2) {
        e.preventDefault(); // 禁止網頁滾動與橡皮筋效果

        const t1 = e.touches[0];
        const t2 = e.touches[1];

        // 1. 計算目前的中心點與距離
        const curDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
        const curMid = {
            x: (t1.clientX + t2.clientX) / 2,
            y: (t1.clientY + t2.clientY) / 2
        };

        // 2. 處理平移 (Panning)
        // 計算中心點位移量
        const dx = curMid.x - lastTouchMid.x;
        const dy = curMid.y - lastTouchMid.y;
        
        // 將位移量套用到 Camera（記得除以 scale）
        camera.x -= dx / camera.scale;
        camera.y -= dy / camera.scale;

        // 3. 處理縮放 (Zooming)
        const zoomFactor = curDist / lastTouchDist;
        const oldScale = camera.scale;
        
        camera.scale *= zoomFactor;
        camera.scale = Math.max(0.1, Math.min(camera.scale, 100));

        // 修正縮放中心，使其對準雙指中點
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        const midCanvasX = (curMid.x - centerX) / oldScale + camera.x;
        const midCanvasY = (curMid.y - centerY) / oldScale + camera.y;
        
        camera.x = midCanvasX - (curMid.x - centerX) / camera.scale;
        camera.y = midCanvasY - (curMid.y - centerY) / camera.scale;

        // 更新最後狀態
        lastTouchDist = curDist;
        lastTouchMid = curMid;

        draw();
    }
}, { passive: false });
banner.addEventListener('pointermove', (e) => {
    mouse.show = false;
    draw();
});
function screenToCanvas(screenX, screenY) {
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    return {
        x: (screenX - centerX) / camera.scale + camera.x,
        y: (screenY - centerY) / camera.scale + camera.y
    };
}
function canvasToScreen(canvasX, canvasY) {
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    return {
        x: (canvasX - camera.x) * camera.scale + centerX,
        y: (canvasY - camera.y) * camera.scale + centerY
    };
}
function getSnapDist() {
    return BASE_SNAP_DIST / camera.scale;
}
function recordAction(obj, list) {
    // 如果在 Undo 的過程中執行了新動作，刪除後面的紀錄
    history.splice(historyIndex + 1);
    
    history.push({
        obj: obj,
        list: list // 指向 points, lines 或 circles
    });
    
    historyIndex++;
    updateHistoryButtons();
}
function undo() {
    if (historyIndex >= 0) {
        const action = history[historyIndex];
        // 從目前的顯示陣列中移除該物件
        const idx = action.list.indexOf(action.obj);
        if (idx > -1) action.list.splice(idx, 1);
        
        historyIndex--;
        updateHistoryButtons();
        draw();
    }
}
function redo() {
    if (historyIndex < history.length - 1) {
        historyIndex++;
        const action = history[historyIndex];
        // 將物件放回顯示陣列
        action.list.push(action.obj);
        
        updateHistoryButtons();
        draw();
    }
}
function updateHistoryButtons() {
    btnUndo.disabled = historyIndex < 0;
    btnRedo.disabled = historyIndex >= history.length - 1;
}
function setMode(newMode) {
    mode = newMode;
    selectedPoint = null;
    btnMove.classList.toggle("active", mode === Mode.MOVE);
    btnPoint.classList.toggle("active", mode === Mode.POINT);
    btnLine.classList.toggle("active", mode === Mode.LINE);
    btnCircle.classList.toggle("active", mode === Mode.CIRCLE);
}
btnMove.onclick = () => setMode(Mode.MOVE);
btnPoint.onclick = () => setMode(Mode.POINT);
btnLine.onclick = () => setMode(Mode.LINE);
btnCircle.onclick = () => setMode(Mode.CIRCLE);
btnUndo.onclick = undo;
btnRedo.onclick = redo;

document.onkeydown = (e) => {
    if (e.key === "Escape") {
        selectedPoint = null;
        draggingPoint = null;
        draw();
    }
    if (e.key.toLocaleLowerCase() == 'z') {
        e.preventDefault();
        undo();
    }
    if (e.key.toLocaleLowerCase() == 'y') {
        e.preventDefault();
        redo();
    }
    if(e.key==1){
        setMode(Mode.MOVE);
    }
    if(e.key==2){
        setMode(Mode.POINT);
    }
    if(e.key==3){
        setMode(Mode.LINE);
    }
    if(e.key==4){
        setMode(Mode.CIRCLE);
    }
};
function handleDrawingLogic(mx, my) {
    // 若 mode = point，直接新增自由點
    if (mode === Mode.POINT) {
        // 檢查是否已有該點
        for (const p of points) {
            if (dist(p, {x: mx, y: my}) < getSnapDist()) {
                return;
            }
        }
        
        // 嘗試在交點創建點
        const intersection = findNearestIntersection(mx, my);
        if (intersection) {
            points.push(intersection);
            recordAction(intersection, points);
            draw();
            return;
        }
        
        // 檢查是否在線段上
        for (const line of lines) {
            if (pointNearLine(mx, my, line)) {
                createPointOnLine(line, mx, my);
                draw();
                return;
            }
        }
        
        // 檢查是否在圓形上
        for (const circle of circles) {
            if (pointNearCircle(mx, my, circle)) {
                createPointOnCircle(circle, mx, my);
                draw();
                return;
            }
        }
        
        // 都不在，創建自由點
        createFreePoint(mx, my);
        draw();
    }

    // mode = line: 點擊兩個點來創建直線
    if (mode === Mode.LINE) {
        const nearbyPoint = findNearestPoint(mx, my);
        if (nearbyPoint) {
            if (!selectedPoint) {
                selectedPoint = nearbyPoint;
                draw();
            } else {
                if (selectedPoint === nearbyPoint) {
                    selectedPoint = null;
                    draw();
                    return;
                }
                const exists = lines.some(l => {
                    const onLine1 = pointOnLine(selectedPoint, l);
                    const onLine2 = pointOnLine(nearbyPoint, l);
                    return onLine1 && onLine2;
                });
                if (exists) {
                    selectedPoint = null;
                    draw();
                    return;
                }
                // 創建直線
                const line = new Line(selectedPoint, nearbyPoint);
                lines.push(line);
                recordAction(line, lines);
                selectedPoint = null;
                draw();
            }
        }
    }

    // mode = circle: 點擊中心和半徑點來創建圓
    if (mode === Mode.CIRCLE) {
        const nearbyPoint = findNearestPoint(mx, my);
        if (nearbyPoint) {
            if (!selectedPoint) {
                selectedPoint = nearbyPoint;
                draw();
            } else {
                if (selectedPoint === nearbyPoint) {
                    selectedPoint = null;
                    draw();
                    return;
                }
                const exists = circles.some(c => {
                    const centerMatch = Math.abs(dist(selectedPoint, c.center)) < EPS;
                    const radiusMatch = Math.abs(dist(nearbyPoint, c.center) - c.r) < EPS;
                    return centerMatch && radiusMatch;
                });
                if (exists) {
                    selectedPoint = null;
                    draw();
                    return;
                }
                // 創建圓
                const circle = new Circle(selectedPoint, nearbyPoint);
                circles.push(circle);
                recordAction(circle, circles);
                selectedPoint = null;
                draw();
            }
        }
    }
}
window.addEventListener("pointermove", (e) => {
    if (isPanning) {
        const dx = e.clientX - panStartX;
        const dy = e.clientY - panStartY;
        camera.x -= dx / camera.scale;
        camera.y -= dy / camera.scale;
        panStartX = e.clientX;
        panStartY = e.clientY;
        draw();
    }
    const isOverUI = e.target.closest('#banner') || 
                     e.target.closest('#inff') || 
                     e.target.closest('#inf');
    if (isOverUI) {
        mouse.show = false;
        hoveredPoint = null;
        draw();
        return;
    }
    const canvasPos = screenToCanvas(e.clientX, e.clientY);
    const mx = canvasPos.x;
    const my = canvasPos.y;
    mouse.x = mx;
    mouse.y = my;
    mouse.show = true;
    
    hoveredPoint = null;
    if(isPanning) return;
    if(draggingPoint) return; // 拖曳中不更新懸停點
    const np = nearbyVisiblePoint(mx, my);
    
    if(np?.type.dof==0 && mode===Mode.MOVE){
        cvs.style.cursor = 'not-allowed';
        draw();
        return;
    }
    cvs.style.cursor = isPanning ? 'grabbing' : 'auto';
    hoveredPoint = np;
    draw();
});
window.addEventListener("pointerdown", (e) => {
    if (e.target !== cvs) return;
    const canvasPos = screenToCanvas(e.clientX, e.clientY);
    const mx = canvasPos.x;
    const my = canvasPos.y;
    
    mouse.x = mx;
    mouse.y = my;
    mouse.show = true;

    if (e.button === 1) {
        isPanning = true;
        panStartX = e.clientX;
        panStartY = e.clientY;
        cvs.style.cursor = 'grabbing';
        return;
    }

    
    // 找最近點（mode = move）
    if (mode === Mode.MOVE) {
        const np=nearbyVisiblePoint(mx, my);
        if(np){
            draggingPoint = np;
            dragPoint(draggingPoint, mx, my);
            draw();
            const moveHandler = (ev) => {
                const cp = screenToCanvas(ev.clientX, ev.clientY);
                dragPoint(draggingPoint, cp.x, cp.y);
                draw();
            };

            const upHandler = () => {
                window.removeEventListener("pointermove", moveHandler);
                window.removeEventListener("pointerup", upHandler);
                window.removeEventListener("pointercancel", upHandler);
                draggingPoint = null;
                draw();
            };

            window.addEventListener("pointermove", moveHandler);
            window.addEventListener("pointerup", upHandler);
            window.addEventListener("pointercancel", upHandler);
        }
    }
    if (e.pointerType === 'mouse') {
        handleDrawingLogic(mx, my);
    }
});
window.addEventListener("pointerup", (e) => {
    if (e.pointerType === 'touch' && !isMultiTouch && !isPanning&&e.target === cvs) {
        const canvasPos = screenToCanvas(e.clientX, e.clientY);
        handleDrawingLogic(canvasPos.x, canvasPos.y);
    }
    
    // 手機端放開後隱藏預覽
    mouse.show = false; 
    
    resetState();
});
window.addEventListener("pointercancel", resetState);
window.addEventListener("blur", resetState);
window.addEventListener("wheel", (e) => {
    e.preventDefault();
    const zoomSpeed = 0.1;
    const oldScale = camera.scale;
    
    // 改变缩放
    if (e.deltaY > 0) {
        camera.scale *= (1 - zoomSpeed);
    } else {
        camera.scale *= (1 + zoomSpeed);
    }
    camera.scale = Math.max(0.1, Math.min(camera.scale, 100));
    
    // 以鼠标位置为中心缩放：调整相机位置以保持缩放中心
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    const mouseCanvasX = (e.clientX - centerX) / oldScale + camera.x;
    const mouseCanvasY = (e.clientY - centerY) / oldScale + camera.y;
    
    camera.x = mouseCanvasX - (e.clientX - centerX) / camera.scale;
    camera.y = mouseCanvasY - (e.clientY - centerY) / camera.scale;
    
    draw();
}, { passive: false });
function resetState() {
    isPanning = false;
    draggingPoint = null;
    hoveredPoint = null;
    mouse.show = false;
    cvs.style.cursor = 'auto';
    draw();
}
function nearbyVisiblePoint(mx, my) {
    let minDist = getSnapDist();
    let np=null;
    for (const p of points) {
        if(!p.visible) continue;
        const d = dist(p, {x: mx, y: my});
        if (d < minDist) {
            minDist = d;
            np = p;
        }
    }
    return np;
}
function findNearestPoint(mx, my) {
    for (const p of points) {
        if (dist(p, {x: mx, y: my}) < getSnapDist()) {
            return p;
        }
    }
    return null;
}
function findNearestIntersection(mx, my) {
    const snapPoints = [];

    // 線與線交點
    for (let i = 0; i < lines.length; i++) {
        for (let j = i + 1; j < lines.length; j++) {
            const inter = intersectLineLine(lines[i], lines[j]);
            if (inter && dist(inter, {x: mx, y: my}) < getSnapDist()) {
                snapPoints.push({
                    point: inter,
                    type: PointType.LINE_LINE,
                    ref: [lines[i], lines[j]],
                    index: 0
                });
            }
        }
    }

    // 圓與圓交點
    for (let i = 0; i < circles.length; i++) {
        for (let j = i + 1; j < circles.length; j++) {
            const inters = intersectCircleCircle(circles[i], circles[j]);
            for (let k = 0; k < inters.length; k++) {
                const p = inters[k];
                if (dist(p, {x: mx, y: my}) < getSnapDist()) {
                    snapPoints.push({
                        point: p,
                        type: PointType.CIRCLE_CIRCLE,
                        ref: [circles[i], circles[j]],
                        index: k
                    });
                }
            }
        }
    }

    // 線與圓交點
    for (let i = 0; i < lines.length; i++) {
        for (let j = 0; j < circles.length; j++) {
            const inters = intersectLineCircle(lines[i], circles[j]);
            for (let k = 0; k < inters.length; k++) {
                const p = inters[k];
                if (dist(p, {x: mx, y: my}) < getSnapDist()) {
                    snapPoints.push({
                        point: p,
                        type: PointType.LINE_CIRCLE,
                        ref: [lines[i], circles[j]],
                        index: k
                    });
                }
            }
        }
    }

    if (snapPoints.length > 0) {
        // 按距離排序，返回最近的
        snapPoints.sort((a, b) => dist(a.point, {x: mx, y: my}) - dist(b.point, {x: mx, y: my}));
        // 構造完整的 Point 對象
        const info = snapPoints[0];
        return new Point(
            info.point.x,
            info.point.y,
            info.type,
            info.ref,
            0,
            info.index
        );
    }

    return null;
}
function pointNearLine(x, y, line) {
    const d = Math.abs(line.A * x + line.B * y + line.C) / Math.hypot(line.A, line.B);
    return d < getSnapDist();
}
function pointNearCircle(x, y, circle) {
    const d = Math.abs(dist({x, y}, circle.center) - circle.r);
    return d < getSnapDist();
}

function dragPoint(p, mx, my) {
    const snap = new Point(mx, my);

    if (p.type === PointType.FREE) {
        p.x = snap.x;
        p.y = snap.y;
    } else if (p.type === PointType.ON_LINE) {
        const { p1, p2 } = p.ref;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len2 = dx * dx + dy * dy;
        p.t = ((snap.x - p1.x) * dx + (snap.y - p1.y) * dy) / len2;
        p.update();
    } else if (p.type === PointType.ON_CIRCLE) {
        p.t = Math.atan2(snap.y - p.ref.center.y, snap.x - p.ref.center.x);
        p.update();
    }
}
function snapToPoint(x, y) {
    for (const p of points) {
        if (dist({x, y}, p) < getSnapDist()) {
            return {x: p.x, y: p.y}; // 吸附到現有點
        }
    }
    return {x, y}; // 沒有吸附
}
function snapToIntersection(x, y) {
    const snapPoints = [];

    // 所有線與線交點
    for (let i=0;i<lines.length;i++) {
        for (let j=i+1;j<lines.length;j++) {
            const inter = intersectLineLine(lines[i], lines[j]);
            if (inter && dist(inter, {x,y}) < getSnapDist()) snapPoints.push(inter);
        }
    }

    // 所有圓與圓交點
    for (let i=0;i<circles.length;i++) {
        for (let j=i+1;j<circles.length;j++) {
            const inters = intersectCircleCircle(circles[i], circles[j]);
            for (const p of inters) if (dist(p, {x,y}) < getSnapDist()) snapPoints.push(p);
        }
    }

    // 圓與線交點
    for (const c of circles) {
        for (const l of lines) {
            const inters = intersectLineCircle(l, c);
            for (const p of inters) if (dist(p, {x,y}) < getSnapDist()) snapPoints.push(p);
        }
    }

    if (snapPoints.length > 0) {
        // 回傳離滑鼠最近的
        snapPoints.sort((a,b)=>dist(a,{x,y})-dist(b,{x,y}));
        return snapPoints[0];
    }

    return {x,y};
}

class Point {
    constructor(x, y, type = PointType.FREE, ref = null, t=0,index = 0) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.ref = ref;   // 对于交点，ref 是 [line1, line2] 或 [circle1, circle2] 等
        this.t = t; // 用於參數化位置（線上或圓上）
        this.index = index; // 如果有多个交点，用来区分第几个
        this.visible = true;
    }

    update() {
        if (this.type === PointType.ON_LINE) {
            const { p1, p2 } = this.ref;
            this.x = p1.x + this.t * (p2.x - p1.x);
            this.y = p1.y + this.t * (p2.y - p1.y);
        }

        if (this.type === PointType.ON_CIRCLE) {
            this.x = this.ref.center.x + this.ref.r * Math.cos(this.t);
            this.y = this.ref.center.y + this.ref.r * Math.sin(this.t);
        }

        if (this.type === PointType.LINE_LINE) {
            const [l1, l2] = this.ref;
            const result = intersectLineLine(l1, l2);
            if (result) {
                this.x = result.x;
                this.y = result.y;
                this.visible = true;
            }else{
                this.visible = false;
            }
        }

        if (this.type === PointType.CIRCLE_CIRCLE) {
            const [c1, c2] = this.ref;
            const results = intersectCircleCircle(c1, c2);
            if(results.length ==0) {
                this.visible = false;
            }else if (results.length > this.index) {
                const currentOccupied = points.some((p, idx) => 
                    p !== this && 
                    idx < points.indexOf(this) &&
                    pointOnCircle(p, c1) &&
                    pointOnCircle(p, c2) &&
                    dist(p, results[this.index]) < EPS
                );
                
                if (currentOccupied) {
                    this.index = 1 - this.index;
                }
                
                if (results.length > this.index) {
                    this.x = results[this.index].x;
                    this.y = results[this.index].y;
                    this.visible = true;
                } else {
                    this.visible = false;
                }
            }
        }

        if (this.type === PointType.LINE_CIRCLE) {
            const [l, c] = this.ref;
            const results = intersectLineCircle(l, c);
            if(results.length ==0) {
                this.visible = false;
            }else if (results.length > this.index) {
                this.x = results[this.index].x;
                this.y = results[this.index].y;
                this.visible = true;
            }
        }
    }
}
class Line {
    constructor(p1, p2) {
        // Ax + By + C = 0
        this.p1 = p1;
        this.p2 = p2;
    }
    
    get A() {
        return this.p2.y - this.p1.y;
    }
    
    get B() {
        return this.p1.x - this.p2.x;
    }
    
    get C() {
        return -(this.A * this.p1.x + this.B * this.p1.y);
    }
}
class Circle {
    constructor(center, p) {
        this.center = center;
        this.p = p;
    }
    get r() {
        return dist(this.center, this.p);
    }
}

function dist(p, q) {
    return Math.hypot(p.x - q.x, p.y - q.y);
}
function $(el) {
    return document.querySelector(el);
}
function DegToRad(a) {
    return a * Math.PI / 180;
}
function random(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
}
function HSLToRGB(h, s, l) {
    s /= 100;
    l /= 100;
    let c = (1 - Math.abs(2 * l - 1)) * s,
        x = c * (1 - Math.abs((h / 60) % 2 - 1)),
        m = l - c / 2,
        r = 0,
        g = 0,
        b = 0;
    if (0 <= h && h < 60) {
        r = c; g = x; b = 0;
    } else if (60 <= h && h < 120) {
        r = x; g = c; b = 0;
    } else if (120 <= h && h < 180) {
        r = 0; g = c; b = x;
    } else if (180 <= h && h < 240) {
        r = 0; g = x; b = c;
    } else if (240 <= h && h < 300) {
        r = x; g = 0; b = c;
    } else if (300 <= h && h < 360) {
        r = c; g = 0; b = x;
    }
    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);

    return "rgb(" + r + "," + g + "," + b + ")";
}

function createFreePoint(mx, my) {
    const snap = snapToPoint(mx, my);
    const p = new Point(snap.x, snap.y, PointType.FREE);
    points.push(p);
    recordAction(p, points);
    return p;
}
function createPointOnLine(line, mx, my) {
    const { p1, p2 } = line;
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const len2 = dx * dx + dy * dy;
    
    const t = ((mx - p1.x) * dx + (my - p1.y) * dy) / len2;
    
    const p = new Point(0, 0, PointType.ON_LINE, line, t);
    p.update();
    points.push(p);
    recordAction(p, points);
    return p;
}
function createPointOnCircle(circle, mx, my) {
    const angle = Math.atan2(my - circle.center.y, mx - circle.center.x);
    const p = new Point(0, 0, PointType.ON_CIRCLE, circle, angle);
    p.update();
    points.push(p);
    recordAction(p, points);
    return p;
}

function intersectCircleCircle(c0, c1) {
    const x0 = c0.center.x, y0 = c0.center.y;
    const x1 = c1.center.x, y1 = c1.center.y;
    const r0 = c0.r, r1 = c1.r;

    const dx = x1 - x0;
    const dy = y1 - y0;
    const d = Math.hypot(dx, dy);

    // 無交點
    if (d > r0 + r1 + EPS) return [];
    if (d < Math.abs(r0 - r1) - EPS) return [];
    if (d < EPS && Math.abs(r0 - r1) < EPS) {
        // 重合（通常不處理）
        return [];
    }

    // a = 到交點連線投影長
    const a = (r0 * r0 - r1 * r1 + d * d) / (2 * d);

    // h = 垂直高度
    const h2 = r0 * r0 - a * a;
    const h = Math.sqrt(Math.max(0, h2));

    // 中點
    const xm = x0 + a * dx / d;
    const ym = y0 + a * dy / d;

    // 偏移向量
    const rx = -dy * (h / d);
    const ry = dx * (h / d);

    const p1 = { x: xm + rx, y: ym + ry };
    const p2 = { x: xm - rx, y: ym - ry };

    // 切線（h ≈ 0）
    if (h < EPS) return uniquePoints(h < EPS ? [p1] : [p1, p2]);

    return [p1, p2];
}
function intersectLineLine(l1, l2) {
    const D = l1.A * l2.B - l2.A * l1.B;
    if (Math.abs(D) < EPS) return null;

    const x = (l1.B * l2.C - l2.B * l1.C) / D;
    const y = (l2.A * l1.C - l1.A * l2.C) / D;
    return new Point(x, y);
}
function intersectLineCircle(line, circle) {
    // 投影法（穩定）
    const { A, B, C } = line;
    const { x: x0, y: y0 } = circle.center;

    const d = Math.abs(A * x0 + B * y0 + C) / Math.hypot(A, B);
    if (d > circle.r + EPS) return [];

    const t = -(A * x0 + B * y0 + C) / (A * A + B * B);
    const x = x0 + A * t;
    const y = y0 + B * t;

    const h = Math.sqrt(Math.max(0, circle.r ** 2 - d ** 2));
    const vx = -B / Math.hypot(A, B);
    const vy = A / Math.hypot(A, B);

    if (h < EPS) {
    return [new Point(x, y)];
    }

    return [
        new Point(x + vx * h, y + vy * h),
        new Point(x - vx * h, y - vy * h)
    ];
}
function pointOnLine(p, line) {
    return Math.abs(line.A * p.x + line.B * p.y + line.C)
        / Math.hypot(line.A, line.B) < EPS;
}
function pointOnCircle(p, c) {
  return Math.abs(dist(p, c.center) - c.r) < EPS;
}
function equalLength(p1, p2, p3, p4) {
    return Math.abs(dist(p1, p2) - dist(p3, p4)) < EPS;
}
function dot(l1, l2) {
    return l1.A * l2.A + l1.B * l2.B;
}
function perpendicular(l1, l2) {
    return Math.abs(dot(l1, l2)) < EPS;
}
function parallel(l1, l2) {
    return Math.abs(l1.A * l2.B - l2.A * l1.B) < EPS;
}
function uniquePoints(points) {
    const res = [];
    for (const p of points) {
        if (!res.some(q => dist(p, q) < EPS)) {
            res.push(p);
        }
    }
    return res;
}

function drawPoint(p,clr="#f0f") {
    if(!p.visible) return;
    ctx.beginPath();
    ctx.arc(p.x, p.y, BASE_SNAP_DIST*0.8/camera.scale, 0, Math.PI*2);
    ctx.fillStyle = clr;
    ctx.strokeStyle = "#000";
    ctx.lineWidth=1/camera.scale;
    ctx.fill();
    ctx.stroke();
}
function drawLine(line, style = "#0f0") {
    const p1 = line.p1;
    const p2 = line.p2;
    
    if(!p1.visible || !p2.visible) return;
    
    // 計算方向向量
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const len = Math.hypot(dx, dy);
    const ux = dx / len;
    const uy = dy / len;
    
    // 沿著方向延伸
    const t_large = 2000;
    const x1 = p1.x - ux * t_large;
    const y1 = p1.y - uy * t_large;
    const x2 = p2.x + ux * t_large;
    const y2 = p2.y + uy * t_large;
    
    ctx.strokeStyle = style;
    ctx.lineWidth = 3*(1+isMobile*0.3)/camera.scale;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}
function drawCircle(circle, style = "#0ff") {
    if(!circle.center.visible||!circle.p.visible) return;
    ctx.strokeStyle = style;
    ctx.lineWidth = 3*(1+isMobile*0.3)/camera.scale;
    ctx.beginPath();
    ctx.arc(circle.center.x, circle.center.y, dist(circle.center, circle.p), 0, Math.PI * 2);
    ctx.stroke();
}
function draw() {
    bk();
    let gdt = ctx.createLinearGradient(0, 0, window.innerWidth, window.innerHeight);
    gdt.addColorStop(1, "#f00");
    gdt.addColorStop(0, "#f0f");
    ctx.strokeStyle = gdt;
    ctx.lineWidth = 10;
    ctx.strokeRect(0, 0, window.innerWidth, window.innerHeight);

    ctx.save();
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    ctx.translate(centerX, centerY);
    ctx.scale(camera.scale, camera.scale);
    ctx.translate(-camera.x, -camera.y);

    for (const p of points) {
        p.update();
    }
    for (const l of lines) drawLine(l);
    for (const c of circles) drawCircle(c);

    if(mouse.show&&!isPanning){
        if(selectedPoint){
            const mousePoint = (hoveredPoint)? hoveredPoint : { x: mouse.x, y: mouse.y, visible: true };
            
            ctx.save();
            ctx.setLineDash([5 / camera.scale, 5 / camera.scale]); // 設置虛線，讓預覽更有質感
            const clr="#fff8";
            if(mode === Mode.LINE){
                drawLine(new Line(selectedPoint, mousePoint), clr);
            } else if(mode === Mode.CIRCLE){
                drawCircle(new Circle(selectedPoint, mousePoint), clr);
            }
            ctx.restore();
        }
        if (mode === Mode.POINT&&!isMultiTouch) {
            const mx = mouse.x;
            const my = mouse.y;
            
            // 優先順序：1. 現有的點 2. 交點 3. 線上/圓上的投影點 4. 自由點
            let pPos = null;

            if (hoveredPoint) {
                // 1. 吸附到現有的點
                pPos = { x: hoveredPoint.x, y: hoveredPoint.y };
            } else {
                const intersection = findNearestIntersection(mx, my);
                const clr="#f00a";
                if (intersection) {
                    // 2. 吸附到交點
                    pPos = { x: intersection.x, y: intersection.y };
                    if(intersection.type === PointType.LINE_LINE){
                        const [l1, l2] = intersection.ref;
                        drawLine(l1, clr);
                        drawLine(l2, clr);
                    }else if(intersection.type === PointType.CIRCLE_CIRCLE){
                        const [c1, c2] = intersection.ref;
                        drawCircle(c1, clr);
                        drawCircle(c2, clr);
                    }else if(intersection.type === PointType.LINE_CIRCLE){
                        const [l, c] = intersection.ref;
                        drawLine(l, clr);
                        drawCircle(c, clr);
                    }
                } else {
                    // 3. 檢查是否在線段上
                    let foundOnGeometry = false;
                    for (const line of lines) {
                        if (pointNearLine(mx, my, line)) {
                            const { p1, p2 } = line;
                            const dx = p2.x - p1.x;
                            const dy = p2.y - p1.y;
                            const len2 = dx * dx + dy * dy;
                            const t = ((mx - p1.x) * dx + (my - p1.y) * dy) / len2;
                            pPos = {
                                x: p1.x + t * dx,
                                y: p1.y + t * dy
                            };
                            foundOnGeometry = true;
                            drawLine(line, clr);
                            break;
                        }
                    }
                    
                    // 4. 檢查是否在圓形上 (如果沒在線上)
                    if (!foundOnGeometry) {
                        for (const circle of circles) {
                            if (pointNearCircle(mx, my, circle)) {
                                const angle = Math.atan2(my - circle.center.y, mx - circle.center.x);
                                pPos = {
                                    x: circle.center.x + circle.r * Math.cos(angle),
                                    y: circle.center.y + circle.r * Math.sin(angle)
                                };
                                foundOnGeometry = true;
                                drawCircle(circle, clr);
                                break;
                            }
                        }
                    }

                    // 5. 都沒有，就是自由點
                    if (!foundOnGeometry) {
                        pPos = { x: mx, y: my };
                    }
                }
            }
            const previewRadius = isMobile ? BASE_SNAP_DIST * 1.2 : BASE_SNAP_DIST * 0.8;
            ctx.beginPath();
            ctx.arc(pPos.x, pPos.y, previewRadius / camera.scale, 0, Math.PI * 2);
            ctx.fillStyle = "#fff8";
            ctx.fill();
        }
    }
    for (const p of points){
        if(p.type.dof==2){
            drawPoint(p, "#ff00ff");
        }else if(p.type.dof==1){
            drawPoint(p, "#800");
        }else{
            drawPoint(p, "#00f");
        }
    }
    
    // 繪製懸停點的 highlight
    if (hoveredPoint) {
        drawPoint(hoveredPoint, "#ffff00");
    }
    
    // 繪製已選中點的 highlight
    if (selectedPoint) {
        drawPoint(selectedPoint, "#ff5500");
    }

    // 繪製拖曳中點的 highlight
    if (draggingPoint) {
        if(draggingPoint.type.dof>0){
            drawPoint(draggingPoint, "#ffffff");
        }
    }
    ctx.restore();
}

function bk() {
    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    ctx.save();
    ctx.fillStyle = "#181818";
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
    ctx.restore();
}
draw();
setMode(mode);
updateHistoryButtons();
</script>
</body>

</html>