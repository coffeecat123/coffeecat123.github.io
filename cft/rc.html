<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>?</title>
    <style>
body, html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    position: fixed;
    background: #000;
}

* {
    font-family: "Comic Sans MS", 標楷體;
    outline: none;
}

#cvs {
    position: fixed;
    top: 0;
    left: 0;
    display: block;
    z-index: 0;
    touch-action: none;
}

#banner {
    position: relative;
    z-index: 3; 
    display: flex;
    align-items: center;
    margin: 10px;
    pointer-events: auto;
    width: fit-content;
    gap: 8px;
    pointer-events: none; 
    user-select: none;
}

#banner button {
    padding: 0 12px;
    height: 38px;
    font-size: 16px;
    background: #444;
    color: #fff;
    border: none;
    outline: none;
    border-radius: 7px;
    cursor: pointer;
    transition: background 0.2s;
    
    display: inline-flex;
    align-items: center;
    justify-content: center;
    vertical-align: middle;
}
#banner button:disabled {
    color: #888;
}
#banner button:hover {
    background: #666;
}
#banner button.active {
    background: #1b72c2;
    color: #0ff;
}
#banner button:has(svg) {
    width: 38px;
    padding: 0;
}
#banner svg {
    width: 20px;
    height: 20px;
    stroke: currentColor;
    fill: currentColor;
    display: block;
    transition: .5s;
}
#hideLine {
    transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s ease;
    transform-origin: center;
    transform: scale(0);
    opacity: 0;
}
#btnHide.active #hideLine {
    transform: scale(1);
    opacity: 1;
}
#banner button, 
#banner select, 
#banner input,
#macroPanel {
    pointer-events: auto;
}
.mobile-break {
    display: none;
}
#inff{
    padding: 0px 4px 4px 4px;
    border: 1.5px #00ffbf solid;
    z-index: 5;
    top: 0;
    right: 0px;
    position: fixed;
    width: 250px;
    white-space: pre;
    color: #fff;
    background: rgb(40, 40, 40);
    display: none;
}
#inf{
    z-index: 10;
    position: fixed;
    top: 5px;
    right: 4px;
}
.tt{
    color: #fff;
    font-size: 25px;
}

svg#svg2{
    fill: #a7a7a7;
    position: relative;
    top: 2.9px;
    left: -1px;
    cursor: pointer;
}
svg#svg2:hover{
    fill: #ffffff;
}
button.btn,button.btn1 {
    background: transparent;
    border: none;
    height: 30px;
    width: 30px;
    border-radius: 15px;
    outline: none;
}
button.btn:hover {
    background: #909090;
}
.selected-input {
    filter: drop-shadow(0 0 8px #00ffbf);
}
.selected-output {
    filter: drop-shadow(0 0 8px #ff5500);
}
#macroPanel{
    display: none;
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(30, 30, 30, 0.9);
    padding: 15px;
    border: 2px #00ffbf solid;
    color: white;
    z-index: 100;
    border-radius: 8px;
    width: 250px;
}

::-webkit-scrollbar-corner {
    background: #181818;
}

::-webkit-scrollbar-track {
    -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    background-color: #303030;
}

::-webkit-scrollbar-thumb:hover {
    background: #6c6c6c;
}

::-webkit-scrollbar-thumb {
    background-color: #a1a1a1;
    border-radius: 10px;
}

::-webkit-scrollbar {
    width: 10px;
    height: 10px;
}

::-webkit-resizer {
    background: #828282;
    outline: 2px solid #b6b6b6;
}
@media screen and (max-width: 768px) {
    #banner {
        flex-wrap: wrap !important; 
        width: calc(100% - 20px) !important;
        gap: 3px 8px;
    }

    #banner button {
        font-size: 20px !important;
        margin: 0 !important;
    }

    #macroPanel {
        bottom: 50px !important;
    }
    
    .mobile-break {
        display: block;
        flex-basis: 100%;
        height: 0;
        margin: 0;
    }
}
    </style>
</head>

<body>
    <div id="banner">
        <button id="btnMove">
            <svg viewBox="0 0 36 36" version="1.1" xmlns="http://www.w3.org/2000/svg"
                style="stroke-width: 0.1px;">
                <path d="M31.46,8.57A3.11,3.11,0,0,0,27,5.75a3.19,3.19,0,0,0-4.66-2.64,3.29,3.29,0,0,0-6.42-.76,3.23,3.23,0,0,0-1.66-.46A3.27,3.27,0,0,0,11,5.18V17.84c-1.28-1.6-2.53-3.18-2.72-3.45A3.19,3.19,0,0,0,5.56,12.9a3.37,3.37,0,0,0-3.47,3.48C2.18,18.18,5.66,24.54,8,28c3.54,5.24,6.92,6,7.07,6l.18,0H25.59a.92.92,0,0,0,.55-.19,13.13,13.13,0,0,0,3.75-6.13c1-3.09,1.53-7.53,1.58-13.56ZM28.18,27.12a12.46,12.46,0,0,1-2.94,5.08H15.33c-.47-.14-3.07-1.1-5.87-5.25S3.94,17.27,3.89,16.29a1.5,1.5,0,0,1,.45-1.13,1.52,1.52,0,0,1,1.14-.46,1.43,1.43,0,0,1,1.32.71c.29.43,2.36,3,3.57,4.53L12.8,18.3V5.18a1.48,1.48,0,1,1,2.95,0V16.32h1.8v-13a1.51,1.51,0,0,1,3,0V16.45h1.8V6a1.43,1.43,0,1,1,2.85,0V17.44H27V8.54a1.33,1.33,0,0,1,2.65,0v5.55C29.62,20,29.14,24.21,28.18,27.12Z"></path>
            </svg>
        </button>
        <button id="btnPoint">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"
                style="transform: matrix(1.5, 0, 0, 1.5, 0, 0);stroke-width: 0.8px;">
                <circle cx="12" cy="12" r="2" fill="none"/>
            </svg>
        </button>
        <button id="btnLine">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"
                style="transform: matrix(1.5, 0, 0, 1.5, 0, 0);stroke-width: 0.8px;">
                <circle cx="6" cy="18" r="2" fill="none"/>
                <circle cx="18" cy="6" r="2" fill="none"/>
                <path d="M 16.585786437626904 7.414213562373095 L 7.414213562373095 16.585786437626904" fill="none"/>
            </svg>
        </button>
        <button id="btnCircle">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"
                style="transform: matrix(1.5, 0, 0, 1.5, 0, 0);stroke-width: 0.8px;">
                <path d="M 20.3368 6.4775 A 10 10 0 1 1 17.5225217277 3.6632288164"  fill="none"/>
                <circle cx="12" cy="12" r="2" fill="none"/>
                <circle cx="19.071067811865476" cy="4.9289321881345245" r="2"  fill="none"/>
            </svg>
        </button>
        <button id="btnHide" title="Show/Hide">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="stroke-width: 2px;">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" stroke="currentColor" fill="none"/>
                <circle cx="12" cy="12" r="3" stroke="currentColor" fill="none"/>
                <line x1="3" y1="21" x2="21" y2="3" stroke="currentColor" id="hideLine" />
            </svg>
        </button>
        <button id="btnUndo" title="Undo">
            <svg viewBox="0 0 24 24" style="transform: matrix(-1.2, 0, 0, 1.2, 0, -1);">
                <path d="M14.6644 5.47875L18.6367 9.00968C20.2053 10.404 20.9896 11.1012 20.9896 11.9993C20.9896 12.8975 20.2053 13.5946 18.6367 14.989L14.6644 18.5199C13.9484 19.1563 13.5903 19.4746 13.2952 19.342C13 19.2095 13 18.7305 13 17.7725V15.4279C9.4 15.4279 5.5 17.1422 4 19.9993C4 10.8565 9.33333 8.57075 13 8.57075V6.22616C13 5.26817 13 4.78917 13.2952 4.65662C13.5903 4.52407 13.9484 4.8423 14.6644 5.47875Z" 
                stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
            </svg>
        </button>
        <button id="btnRedo" title="Redo">
            <svg viewBox="0 0 24 24" style="transform: matrix(1.2, 0, 0, -1.2, 0, 2);" xmlns="http://www.w3.org/2000/svg">
                <path d="M14.6644 5.47875L18.6367 9.00968C20.2053 10.404 20.9896 11.1012 20.9896 11.9993C20.9896 12.8975 20.2053 13.5946 18.6367 14.989L14.6644 18.5199C13.9484 19.1563 13.5903 19.4746 13.2952 19.342C13 19.2095 13 18.7305 13 17.7725V15.4279C9.4 15.4279 5.5 17.1422 4 19.9993C4 10.8565 9.33333 8.57075 13 8.57075V6.22616C13 5.26817 13 4.78917 13.2952 4.65662C13.5903 4.52407 13.9484 4.8423 14.6644 5.47875Z" 
                stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
            </svg>
        </button>
        <div class="mobile-break"></div>
        <button id="btnDefine">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"
                style="transform: matrix(1, 0, 0, 1, 0, 0);stroke-width: 2px;stroke-linecap: round;">
                
                <path d="M 12 3 L 12 21"/>
                <path d="M 3 12 L 21 12"/>
            </svg>
        </button>
        <div id="executeWrapper" style="display: flex; align-items: center;">
            <select id="selectTool" style="user-select: none;height: 38px;padding: 5px; font-size: 16px; background: #444; color: white; border: none; border-radius: 7px; margin-right: 5px; display: none;">
                <option value="">Select Tool...</option>
            </select>
            <button id="btnExecute">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="stroke-width: 1.5px;">
                    <path d="M6 6L10.5 10.5M6 6H3L2 3L3 2L6 3V6ZM19.259 2.74101L16.6314 5.36863C16.2354 5.76465 16.0373 5.96265 15.9632 6.19098C15.8979 6.39183 15.8979 6.60817 15.9632 6.80902C16.0373 7.03735 16.2354 7.23535 16.6314 7.63137L16.8686 7.86863C17.2646 8.26465 17.4627 8.46265 17.691 8.53684C17.8918 8.6021 18.1082 8.6021 18.309 8.53684C18.5373 8.46265 18.7354 8.26465 19.1314 7.86863L21.5893 5.41072C21.854 6.05488 22 6.76039 22 7.5C22 10.5376 19.5376 13 16.5 13C16.1338 13 15.7759 12.9642 15.4298 12.8959C14.9436 12.8001 14.7005 12.7521 14.5532 12.7668C14.3965 12.7824 14.3193 12.8059 14.1805 12.8802C14.0499 12.9501 13.919 13.081 13.657 13.343L6.5 20.5C5.67157 21.3284 4.32843 21.3284 3.5 20.5C2.67157 19.6716 2.67157 18.3284 3.5 17.5L10.657 10.343C10.919 10.081 11.0499 9.95005 11.1198 9.81949C11.1941 9.68068 11.2176 9.60347 11.2332 9.44681C11.2479 9.29945 11.1999 9.05638 11.1041 8.57024C11.0358 8.22406 11 7.86621 11 7.5C11 4.46243 13.4624 2 16.5 2C17.5055 2 18.448 2.26982 19.259 2.74101ZM12.0001 14.9999L17.5 20.4999C18.3284 21.3283 19.6716 21.3283 20.5 20.4999C21.3284 19.6715 21.3284 18.3283 20.5 17.4999L15.9753 12.9753C15.655 12.945 15.3427 12.8872 15.0408 12.8043C14.6517 12.6975 14.2249 12.7751 13.9397 13.0603L12.0001 14.9999Z" fill="none"/>
                </svg>
            </button>
        </div>
        <button id="btnIO" title="Import/Export JSON" style="font-size: 12px;">
            <svg viewBox="0 0 28 28" version="1.1" xmlns="http://www.w3.org/2000/svg"
                style="transform: matrix(0.9, 0, 0, 0.9, 0, 0);stroke-width: 0.8px;">
                <g transform="translate(-310.000000, -933.000000)">
                    <path d="M336,957 C336,958.087 335.087,959 334,959 L313.935,959.033 C312.848,959.033 311.967,958.152 311.967,957.065 L312,937 C312,935.913 312.913,935 314,935 L325,935 L325,933 L314,933 C311.827,933 310,935.221 310,937.394 L310,957.065 C310,959.238 311.762,961 313.935,961 L333.606,961 C335.779,961 338,959.173 338,957 L338,946 L336,946 L336,957 L336,957 Z M336.979,933 L330,933 C329.433,933.001 329.001,933.459 329,934 C328.999,934.541 329.433,935.001 330,935 L334.395,934.968 L319.308,949.357 C318.908,949.738 318.908,950.355 319.308,950.736 C319.706,951.117 320.354,951.117 320.753,950.736 L335.971,936.222 L336,941 C335.999,941.541 336.433,942.001 337,942 C337.567,941.999 337.999,941.541 338,941 L338,933.975 C338.001,933.434 337.546,932.999 336.979,933 L336.979,933 Z">
                    </path>
                </g>
            </svg>
        </button>
        <input type="file" id="fileInput" accept=".json" style="display:none;">
    </div>
    <canvas id="cvs"></canvas>
    <div id="macroPanel">
        <h3 id="macroTitle" style="margin-top:0; color:#00ffbf;">Create Tool</h3>
        <div id="macroStep" style="margin-bottom:10px; font-size:14px; color:#ccc;">Step 1: Select Inputs</div>
        <input type="text" id="toolName" placeholder="Tool Name" style="width:100%; margin-bottom:10px; background:#444; border:none; color:white; padding:5px;">
        <div style="display:flex; gap:5px;">
            <button id="btnMacroNext" style="flex:1; background:#1b72c2; color:white; border:none; padding:5px; cursor:pointer;">Next</button>
            <button id="btnMacroCancel" style="flex:1; background:#666; color:white; border:none; padding:5px; cursor:pointer;">Cancel</button>
        </div>
    </div>
    <button id="inf" class="btn1" onclick="toggleInf()" title="inf">
            <svg id="svg2" width="20px" viewBox="0 0 416.979 416.979"><path d="M356.004,61.156c-81.37-81.47-213.377-81.551-294.848-0.182c-81.47,81.371-81.552,213.379-0.181,294.85   c81.369,81.47,213.378,81.551,294.849,0.181C437.293,274.636,437.375,142.626,356.004,61.156z M237.6,340.786   c0,3.217-2.607,5.822-5.822,5.822h-46.576c-3.215,0-5.822-2.605-5.822-5.822V167.885c0-3.217,2.607-5.822,5.822-5.822h46.576   c3.215,0,5.822,2.604,5.822,5.822V340.786z M208.49,137.901c-18.618,0-33.766-15.146-33.766-33.765   c0-18.617,15.147-33.766,33.766-33.766c18.619,0,33.766,15.148,33.766,33.766C242.256,122.755,227.107,137.901,208.49,137.901z"/></svg>
        </button>
    <div id="inff" class="tt"
><b>Shortcuts</b>
1-7 : Switch Modes
Z   : Undo
Y   : Redo
Esc : Cancel
Wheel : Zoom
Mid-Click : Pan</div>
    <script>
const banner = $("#banner");
const btnMove = $("#btnMove");
const btnPoint = $("#btnPoint");
const btnLine = $("#btnLine");
const btnCircle = $("#btnCircle");
const btnHide = $("#btnHide");
const btnUndo = $("#btnUndo");
const btnRedo = $("#btnRedo");
const btnDefine = $("#btnDefine");
const btnExecute = $("#btnExecute");
const macroPanel = $("#macroPanel");
const macroStepText = $("#macroStep");
const toolNameInput = $("#toolName");
const selectTool = $("#selectTool");
const btnIO = $("#btnIO");
const fileInput = $("#fileInput");
const inff = $("#inff");
const inf = $("#inf");
const cvs = $("#cvs");
const ctx = cvs.getContext("2d");
const points = [];
const lines = [];
const circles = [];
const Mode = {
    MOVE: "move",
    POINT: "point",
    LINE: "line",
    CIRCLE: "circle",
    HIDE: "hide",
    MACRO_DEFINE :"macro_define",
    MACRO_EXECUTE :"macro_execute"
};
const PointType = Object.freeze({
    FREE: { name: "free", dof: 2 },
    ON_LINE: { name: "onLine", dof: 1 },
    ON_CIRCLE: { name: "onCircle", dof: 1 },
    INTERSECTION: { name: "intersection", dof: 0 },
    LINE_LINE: { name: "lineLine", dof: 0 },
    CIRCLE_CIRCLE: { name: "circleCircle", dof: 0 },
    LINE_CIRCLE: { name: "lineCircle", dof: 0 }
});
const camera = {
    x: 0,
    y: 0,
    scale: 1
};
const mouse = { x: 0, y: 0, show:false };
let mode = Mode.MOVE;
let draggingPoint = null; // 正在拖曳的點
let selectedPoint = null; // LINE和CIRCLE模式下的第一個點
let hoveredPoint = null; // 滑鼠懸停的點
let isPanning = false;
let panStartX = 0;
let panStartY = 0;
let infhd=1;
let lastDist = 0;
let lastTouchMid = {x: 0, y: 0};
let isMultiTouch = false;
let touchStartTime = 0;
let touchStartPos = { x: 0, y: 0 };
let pointerStartTime = 0;
let pointerStartPos = { x: 0, y: 0 };
let highlightedObject = null;
let activePointers = new Set();
let touchPendingTimeout = null;

let objectCounter = 0;
const history = [];
let historyIndex = -1;

let macroData = null;
let macroSelection = [];
let macroCreator = {
    stage: 'none', // 'inputs', 'outputs'
    name: '',
    inputs: [],
    outputs: []
};
const tools = []; // 儲存所有自定義工具
let activeTool = null;

const EPS = 1e-6;
const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase());
const BASE_POINT_RADIUS = 10*(1+isMobile*0.3);
const BASE_SNAP_DIST = BASE_POINT_RADIUS*(1+isMobile*0.3);
const dpr = window.devicePixelRatio || 1;

if(isMobile){
    inf.style.display="none";
}

function getUniqueToolName(baseName) {
    let name = baseName.trim() || "Custom Tool";
    let finalName = name;
    let counter = 1;
    
    // 檢查 tools 陣列中是否已有同名工具
    while (tools.some(t => t.name === finalName)) {
        counter++;
        finalName = `${name} (${counter})`;
    }
    return finalName;
}
function updateToolList() {
    if (tools.length === 0) {
        selectTool.style.display = "none";
        return;
    }
    selectTool.style.display = "block";
    selectTool.innerHTML = '<option value="">Select Tool...</option>';
    tools.forEach((t, index) => {
        const opt = document.createElement("option");
        opt.value = index;
        opt.innerText = t.name;
        selectTool.appendChild(opt);
    });
}
function toggleInf(){
    if(infhd){
        inff.style.display="block";
    }
    else{
        inff.style.display="none";
    }
    infhd^=1;
}
function resizeCanvas() {
    const width = window.innerWidth;
    const height = window.innerHeight;

    // 1. 設定畫布內部的渲染解析度 (放大)
    cvs.width = width * dpr;
    cvs.height = height * dpr;

    // 2. 設定畫布在網頁上的顯示大小 (保持不變)
    cvs.style.width = width + 'px';
    cvs.style.height = height + 'px';

    // 3. 核心：將 Context 縮放回邏輯像素，這樣你之後的繪圖邏輯都不用改
    ctx.setTransform(1, 0, 0, 1, 0, 0); // 先重設所有轉換
    ctx.scale(dpr, dpr); 

    draw();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
cvs.addEventListener("touchstart", (e) => {
    if (e.touches.length >= 2) {
        isMultiTouch = true;
        draggingPoint = null;
        isPanning = false;

        const t1 = e.touches[0];
        const t2 = e.touches[1];
        
        // 記錄初始距離
        lastTouchDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
        
        // 記錄初始中心點
        lastTouchMid = {
            x: (t1.clientX + t2.clientX) / 2,
            y: (t1.clientY + t2.clientY) / 2
        };
    }else {
        isMultiTouch = false;
        touchStartTime = Date.now();
        touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
}, { passive: false });
cvs.addEventListener("touchmove", (e) => {
    if (e.touches.length === 2) {
        e.preventDefault(); // 禁止網頁滾動與橡皮筋效果

        const t1 = e.touches[0];
        const t2 = e.touches[1];

        // 1. 計算目前的中心點與距離
        const curDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
        const curMid = {
            x: (t1.clientX + t2.clientX) / 2,
            y: (t1.clientY + t2.clientY) / 2
        };

        // 2. 處理平移 (Panning)
        // 計算中心點位移量
        const dx = curMid.x - lastTouchMid.x;
        const dy = curMid.y - lastTouchMid.y;
        
        // 將位移量套用到 Camera（記得除以 scale）
        camera.x -= dx / camera.scale;
        camera.y -= dy / camera.scale;

        // 3. 處理縮放 (Zooming)
        const zoomFactor = curDist / lastTouchDist;
        const oldScale = camera.scale;
        
        camera.scale *= zoomFactor;
        camera.scale = Math.max(0.1, Math.min(camera.scale, 100));

        // 修正縮放中心，使其對準雙指中點
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        const midCanvasX = (curMid.x - centerX) / oldScale + camera.x;
        const midCanvasY = (curMid.y - centerY) / oldScale + camera.y;
        
        camera.x = midCanvasX - (curMid.x - centerX) / camera.scale;
        camera.y = midCanvasY - (curMid.y - centerY) / camera.scale;

        // 更新最後狀態
        lastTouchDist = curDist;
        lastTouchMid = curMid;

        draw();
    }
}, { passive: false });
banner.addEventListener('pointermove', (e) => {
    mouse.show = false;
    draw();
});
function screenToCanvas(screenX, screenY) {
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    return {
        x: (screenX - centerX) / camera.scale + camera.x,
        y: (screenY - centerY) / camera.scale + camera.y
    };
}
function canvasToScreen(canvasX, canvasY) {
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    return {
        x: (canvasX - camera.x) * camera.scale + centerX,
        y: (canvasY - camera.y) * camera.scale + centerY
    };
}
function getSnapDist() {
    return BASE_SNAP_DIST / camera.scale;
}
function recordAction(obj, list) {
    if (obj.id === null || obj.id === undefined) {
        obj.id = objectCounter++;
    }
    history.splice(historyIndex + 1);
    
    history.push({
        obj: obj,
        list: list // 指向 points, lines 或 circles
    });
    
    historyIndex++;
    updateHistoryButtons();
}
function undo() {
    if (historyIndex >= 0) {
        const action = history[historyIndex];
        // 從目前的顯示陣列中移除該物件
        const idx = action.list.indexOf(action.obj);
        if (idx > -1) action.list.splice(idx, 1);
        
        historyIndex--;
        setMode(mode);
        updateHistoryButtons();
        draw();
    }
}
function redo() {
    if (historyIndex < history.length - 1) {
        historyIndex++;
        const action = history[historyIndex];
        // 將物件放回顯示陣列
        action.list.push(action.obj);
        
        setMode(mode);
        updateHistoryButtons();
        draw();
    }
}
function updateHistoryButtons() {
    btnUndo.disabled = historyIndex < 0;
    btnRedo.disabled = historyIndex >= history.length - 1;
}
function setMode(newMode) {
    mode = newMode;
    macroSelection = [];
    selectedPoint = null;
    draggingPoint = null;
    highlightedObject = null;
    
    if(mode!==Mode.MACRO_DEFINE){
        macroPanel.style.display="none";
        macroCreator = { stage: 'inputs', inputs: [], outputs: [] };
        macroStepText.innerText = "Step 1: Select Input Objects";
        toolNameInput.style.display = "none";
    }else{
        macroPanel.style.display="block";
    }
    
    [btnMove, btnPoint, btnLine, btnCircle, btnHide, btnDefine, btnExecute].forEach(btn => btn.classList.remove("active"));
    if(mode === Mode.MOVE) btnMove.classList.add("active");
    if(mode === Mode.POINT) btnPoint.classList.add("active");
    if(mode === Mode.LINE) btnLine.classList.add("active");
    if(mode === Mode.CIRCLE) btnCircle.classList.add("active");
    if(mode === Mode.HIDE) btnHide.classList.add("active");
    if(mode === Mode.MACRO_DEFINE) btnDefine.classList.add("active");
    if(mode === Mode.MACRO_EXECUTE) btnExecute.classList.add("active");
    
    draw();
}
btnMove.onclick = () => setMode(Mode.MOVE);
btnPoint.onclick = () => setMode(Mode.POINT);
btnLine.onclick = () => setMode(Mode.LINE);
btnCircle.onclick = () => setMode(Mode.CIRCLE);
btnHide.onclick = () => setMode(Mode.HIDE);
btnDefine.onclick = () => {
    setMode(Mode.MACRO_DEFINE);
    macroCreator = { stage: 'inputs', inputs: [], outputs: [] };
    macroStepText.innerText = "Step 1: Select Input Objects";
    toolNameInput.style.display = "none";
};
$("#btnMacroNext").onclick = () => {
    if (macroCreator.stage === 'inputs') {
        if (macroCreator.inputs.length === 0) return alert("Select at least one input!");
        macroCreator.stage = 'outputs';
        macroStepText.innerText = "Step 2: Select Final Objects";
    } else if (macroCreator.stage === 'outputs') {
        if (macroCreator.outputs.length === 0) return alert("Select at least one output!");
        macroCreator.stage = 'naming';
        macroStepText.innerText = "Step 3: Name your Tool";
        toolNameInput.style.display = "block";
        $("#btnMacroNext").innerText = "Save Tool";
    } else {
        const finalName = getUniqueToolName(toolNameInput.value);

        const steps = getMacroSteps(macroCreator.outputs, macroCreator.inputs);
        const newTool = {
            name: finalName, 
            inputs: macroCreator.inputs.map(o => {
                const info = { className: o.constructor.name, id: o.id };
                // 自動找出組成的點 ID
                if (o instanceof Line) {
                    info.sub = [o.p1.id, o.p2.id]; // 紀錄原始 p1, p2 的 ID
                } else if (o instanceof Circle) {
                    info.sub = [o.center.id, o.p.id]; // 紀錄原始 center, p 的 ID
                }
                return info;
            }),
            steps: getMacroSteps(macroCreator.outputs, macroCreator.inputs)
        };
        
        tools.push(newTool);
        updateToolList();
        activeTool = newTool;
        selectTool.value = tools.length - 1;
        alert(`Tool "${finalName}" created!`);
        cancelMacro();
        $("#btnMacroNext").innerText = "Next";
        toolNameInput.value = ""; // 清空輸入框
    }
};
$("#btnMacroCancel").onclick = cancelMacro;
selectTool.onchange = (e) => {
    const toolIndex = e.target.value;
    if (toolIndex === "") {
        activeTool = null;
        setMode(Mode.MOVE);
        return;
    }
    activeTool = tools[toolIndex];
    macroSelection = [];
    setMode(Mode.MACRO_EXECUTE);
    console.log(`Tool "${activeTool.name}" active. Select ${activeTool.inputs.length} objects.`);
};
btnExecute.onclick =()=>{
    setMode(Mode.MACRO_EXECUTE);
};
btnExecute.ondblclick = () => {
    const choice = confirm("Press 'OK' to upload a .json file, or 'Cancel' to paste JSON code.");
    
    if (choice) {
        // 觸發隱藏的檔案選取器
        fileInput.click();
    } else {
        const json = prompt("Paste Tool JSON here:");
        if (json) processImportedJSON(json);
    }
};
fileInput.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
        processImportedJSON(event.target.result);
        fileInput.value = "";
    };
    reader.readAsText(file);
};
btnIO.onclick = () => {
    if (tools.length === 0) return alert("No tools to export.");
    
    // 使用 replacer 函式過濾掉冗餘資訊並限制數字長度
    const jsonString = JSON.stringify(tools, (key, value) => {
        // 1. 移除 null, undefined 或空字串
        if (value === null || value === undefined || value === "") return undefined;
        
        // 2. 移除數值物件中的預設值 (0) 以節省空間
        if ((key === 't' || key === 'index') && value === 0) return undefined;
        
        // 3. 限制浮點數長度（例如參數 t）
        if (typeof value === 'number') return Math.round(value * 1e6) / 1e6;
        
        return value;
    });

    // 彈窗顯示（此時是一整行超長字串，最省空間）
    prompt("Compact Tool JSON:", jsonString);

    if (confirm("Download compact .json file?")) {
        const blob = new Blob([jsonString], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, "");
        a.download = `tools_${timestamp}.json`;
        a.href = url;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
};
btnUndo.onclick = undo;
btnRedo.onclick = redo;
document.onkeydown = (e) => {
    if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    const key = e.key.toLowerCase();
    const modeMap = {
        '1': Mode.MOVE,
        '2': Mode.POINT,
        '3': Mode.LINE,
        '4': Mode.CIRCLE,
        '5': Mode.HIDE,
        '6': Mode.MACRO_DEFINE,
        '7': Mode.MACRO_EXECUTE
    };
    if (modeMap[key]) {
        setMode(modeMap[key]);
        return;
    }

    switch (key) {
        case 'z':
            e.preventDefault();
            undo();
            break;
        case 'y':
            e.preventDefault();
            redo();
            break;
        case 'escape':
            setMode(mode);
            break;
    }
};
function processImportedJSON(jsonString) {
    try {
        const imported = JSON.parse(jsonString);
        const addTool = (tool) => {
            if (tool.name && tool.inputs && tool.steps) {
                // 自動查重與更名
                tool.name = getUniqueToolName(tool.name);
                tools.push(tool);
            }
        };

        if (Array.isArray(imported)) {
            imported.forEach(addTool);
        } else {
            addTool(imported);
        }

        updateToolList();
        alert("Import successful!");
        activeTool = tools[tools.length - 1];
        selectTool.value = tools.length - 1;
    } catch (e) {
        console.error(e);
        alert("Import failed: Invalid file format.");
    }
}
function cancelMacro() {
    macroPanel.style.display = "none";
    macroCreator.stage = 'none';
    macroCreator.inputs = [];
    macroCreator.outputs = [];
    setMode(Mode.MOVE);
    draw();
}

function newPointToActiveMacro(p){
    macroPoints.push(p);
    if(macroPoints.length==activeMacro.inputsCount){
        runMacro();
    }
}
function handleMacroSelection(mx, my) {
    if (mode === Mode.MACRO_DEFINE) {
        const obj = findNearestAny(mx, my);
        if (obj) {
            if (macroCreator.stage === 'inputs') {
                if (macroCreator.inputs.includes(obj)) {
                    macroCreator.inputs = macroCreator.inputs.filter(i => i !== obj);
                } else {
                    if (isInputRedundant(obj, macroCreator.inputs)) {
                        alert("Invalid Input: These objects have dependency relationships.");
                        return;
                    }
                    macroCreator.inputs.push(obj);
                }
            } else if (macroCreator.stage === 'outputs') {
                if (macroCreator.inputs.includes(obj)) {
                    alert("Output cannot be the same as Input.");
                    return;
                }
                if (obj instanceof Point && obj.type === PointType.FREE) {
                    alert("A 'Free Point' cannot be an output.");
                    return;
                }
                if (macroCreator.outputs.includes(obj)) {
                    macroCreator.outputs = macroCreator.outputs.filter(i => i !== obj);
                } else {
                    if (!validateOutput(obj, macroCreator.inputs)) {
                        alert("Invalid Output: Dependency missing from Inputs.");
                        return;
                    }
                    macroCreator.outputs.push(obj);
                }
            }
            draw();
        }
    }
    
    if (mode === Mode.MACRO_EXECUTE) {
        if (!activeTool) return;
        const obj = findNearestAny(mx, my);
        if (obj) {
            const expected = activeTool.inputs[macroSelection.length];
            if(macroSelection.includes(obj)){
                alert("Already selected.");
                return;
            }
            if (obj.constructor.name === expected.className) {
                macroSelection.push(obj);
                if (macroSelection.length === activeTool.inputs.length) {
                    runTool(activeTool, macroSelection);
                    macroSelection = [];
                    console.log("Macro applied!");
                }
            } else {
                alert(`Need a ${expected.className}`);
            }
            draw();
        }
    }
}
function addPoint(mx,my){
    // 檢查是否已有該點
    for (const p of points) {
        if (dist(p, {x: mx, y: my}) < getSnapDist()) {
            return p;
        }
    }
    
    // 嘗試在交點創建點
    const intersection = findNearestIntersection(mx, my);
    if (intersection) {
        points.push(intersection);
        recordAction(intersection, points);
        draw();
        return intersection;
    }
    
    // 檢查是否在線段上
    for (const line of lines) {
        if (pointNearLine(mx, my, line)) {
            const p=createPointOnLine(line, mx, my);
            draw();
            return p;
        }
    }
    
    // 檢查是否在圓形上
    for (const circle of circles) {
        if (pointNearCircle(mx, my, circle)) {
            const p=createPointOnCircle(circle, mx, my);
            draw();
            return p;
        }
    }
    
    // 都不在，創建自由點
    const p = createFreePoint(mx, my);
    draw();
    return p;
}
function addLine(mx,my){
    var nearbyPoint = findNearestPoint(mx, my);
    if(nearbyPoint==null){
        nearbyPoint = addPoint(mx,my);
    }
    if (!selectedPoint) {
        selectedPoint = nearbyPoint;
        draw();
    } else {
        if (selectedPoint === nearbyPoint) {
            selectedPoint = null;
            draw();
            return;
        }
        const exists = findExistingLine(selectedPoint, nearbyPoint);
        if (exists) {
            selectedPoint = null;
            draw();
            return;
        }
        // 創建直線
        const line = new Line(selectedPoint, nearbyPoint);
        lines.push(line);
        recordAction(line, lines);
        selectedPoint = null;
        draw();
    }
}
function addCircle(mx,my){
    var nearbyPoint = findNearestPoint(mx, my);
    if(nearbyPoint==null){
        nearbyPoint = addPoint(mx,my);
    }
    if (!selectedPoint) {
        selectedPoint = nearbyPoint;
        draw();
    } else {
        if (selectedPoint === nearbyPoint) {
            selectedPoint = null;
            draw();
            return;
        }
        const exists = findExistingCircle(selectedPoint, nearbyPoint);
        if (exists) {
            selectedPoint = null;
            draw();
            return;
        }
        // 創建圓
        const circle = new Circle(selectedPoint, nearbyPoint);
        circles.push(circle);
        recordAction(circle, circles);
        selectedPoint = null;
        draw();
    }
}
function handleDrawingLogic(mx, my) {
    if (mode === Mode.POINT) {
        addPoint(mx, my);
        return;
    }
    if (mode === Mode.LINE) {
        addLine(mx, my);
        return;
    }
    if (mode === Mode.CIRCLE) {
        addCircle(mx, my);
        return;
    }
}
function handleMovingLogic(mx, my) {
    const np = nearbyVisiblePoint(mx, my);
    if (np) {
        draggingPoint = np;
        dragPoint(draggingPoint, mx, my);
        draw();
        
        const moveHandler = (ev) => {
            if (isMultiTouch) return; // 拖動中若變雙指則停止
            const cp = screenToCanvas(ev.clientX, ev.clientY);
            dragPoint(draggingPoint, cp.x, cp.y);
            draw();
        };

        const upHandler = () => {
            window.removeEventListener("pointermove", moveHandler);
            window.removeEventListener("pointerup", upHandler);
            window.removeEventListener("pointercancel", upHandler);
            draggingPoint = null;
            draw();
        };

        window.addEventListener("pointermove", moveHandler);
        window.addEventListener("pointerup", upHandler);
        window.addEventListener("pointercancel", upHandler);
        return;
    }
    
    const obj = findNearestAny(mx, my);
    if (obj) {
        highlightedObject = (highlightedObject === obj) ? null : obj;
        draw();
    }
}
function handleHideLogic(mx, my) {
    const obj = findNearestAny(mx, my);
    if (obj) {
        obj.visible = !obj.visible;
        draw();
    }
}
window.addEventListener("pointermove", (e) => {
    if (isPanning) {
        const dx = e.clientX - panStartX;
        const dy = e.clientY - panStartY;
        camera.x -= dx / camera.scale;
        camera.y -= dy / camera.scale;
        panStartX = e.clientX;
        panStartY = e.clientY;
        draw();
    }
    const isOverUI = e.target.closest('button') || 
                     e.target.closest('#inff') || 
                     e.target.closest('#inf');
    if (isOverUI) {
        mouse.show = false;
        hoveredPoint = null;
        draw();
        return;
    }
    if(isMultiTouch){
        mouse.show = false;
        hoveredPoint = null;
        draw();
        return;
    }
    const canvasPos = screenToCanvas(e.clientX, e.clientY);
    const mx = canvasPos.x;
    const my = canvasPos.y;
    mouse.x = mx;
    mouse.y = my;
    mouse.show = true;
    
    hoveredPoint = null;
    if(isPanning) return;
    if(draggingPoint) return;
    const np = nearbyVisiblePoint(mx, my);
    
    if(np?.type.dof==0 && mode===Mode.MOVE){
        cvs.style.cursor = 'not-allowed';
        draw();
        return;
    }
    cvs.style.cursor = isPanning ? 'grabbing' : 'auto';
    hoveredPoint = np;
    draw();
});
window.addEventListener("pointerdown", (e) => {
    pointerStartTime = Date.now();
    activePointers.add(e.pointerId);
    
    if(e.target!==cvs)return;

    if (activePointers.size > 1) {
        if (touchPendingTimeout) {
            clearTimeout(touchPendingTimeout);
            touchPendingTimeout = null;
        }
        isMultiTouch = true;
        mouse.show = false;
        hoveredPoint = null;
        draw();
        return;
    }
    const canvasPos = screenToCanvas(e.clientX, e.clientY);
    const mx = canvasPos.x;
    const my = canvasPos.y;

    pointerStartPos=canvasPos;
    
    mouse.x = mx;
    mouse.y = my;
    mouse.show = true;

    if (e.button === 1) {
        isPanning = true;
        panStartX = e.clientX;
        panStartY = e.clientY;
        cvs.style.cursor = 'grabbing';
        return;
    }

    const executeSinglePointerLogic = () => {
        if (isMultiTouch) return;

        if (mode === Mode.MOVE) {
            handleMovingLogic(mx, my);
            return;
        }
        if (mode === Mode.HIDE) {
            handleHideLogic(mx, my);
            return;
        }

        if (e.pointerType === 'mouse') {
            handleMacroSelection(mx, my);
            handleDrawingLogic(mx, my);
        } else if (e.pointerType === 'touch') {
            if (mode === Mode.LINE || mode === Mode.CIRCLE) {
                handleDrawingLogic(mx, my);
            }
            if (mode === Mode.MACRO_DEFINE || mode === Mode.MACRO_EXECUTE) {
                handleMacroSelection(mx, my);
            }
        }
    };

    if (e.pointerType === 'touch') {
        touchPendingTimeout = setTimeout(() => {
            executeSinglePointerLogic();
            touchPendingTimeout = null;
        }, 20);
    } else {
        executeSinglePointerLogic();
    }
});
window.addEventListener("pointerup", (e) => {

    if (touchPendingTimeout) {
        clearTimeout(touchPendingTimeout);
        touchPendingTimeout = null;
        const canvasPos = screenToCanvas(e.clientX, e.clientY);
        if (mode===Mode.MOVE) handleMovingLogic(canvasPos.x, canvasPos.y);
        if (mode === Mode.POINT) handleDrawingLogic(canvasPos.x, canvasPos.y);
        if (mode === Mode.LINE || mode === Mode.CIRCLE) handleDrawingLogic(canvasPos.x, canvasPos.y);
        if (mode === Mode.HIDE) handleHideLogic(canvasPos.x, canvasPos.y);
        if (mode === Mode.MACRO_DEFINE || mode === Mode.MACRO_EXECUTE) handleMacroSelection(canvasPos.x, canvasPos.y);
    }

    activePointers.delete(e.pointerId);
    if (activePointers.size === 0) {
        setTimeout(() => {
            if (activePointers.size === 0) isMultiTouch = false;
        }, 50); 
    }

    if (isMultiTouch) return;

    if (e.pointerType === 'touch' && !isMultiTouch && !isPanning&&e.target === cvs) {
        const canvasPos = screenToCanvas(e.clientX, e.clientY);
        if(dist(pointerStartPos, canvasPos)>BASE_POINT_RADIUS&&(mode===Mode.LINE||mode===Mode.CIRCLE)&&selectedPoint){
            handleDrawingLogic(canvasPos.x, canvasPos.y);
        }
        if(mode===Mode.POINT){
            handleDrawingLogic(canvasPos.x, canvasPos.y);
        }
    }
    if(e.pointerType === 'mouse' && !isPanning&&e.target === cvs){
        const canvasPos = screenToCanvas(e.clientX, e.clientY);
        if(dist(pointerStartPos, canvasPos)>BASE_POINT_RADIUS&&(mode===Mode.LINE||mode===Mode.CIRCLE)&&selectedPoint){
            handleDrawingLogic(canvasPos.x, canvasPos.y);
        }
    }
    
    mouse.show = false; 
    
    resetState();
});
window.addEventListener("pointercancel", (e) => {
    activePointers.delete(e.pointerId);
    if (activePointers.size === 0) isMultiTouch = false;
    resetState();
});
window.addEventListener("blur", resetState);
window.addEventListener("wheel", (e) => {
    e.preventDefault();
    const zoomSpeed = 0.1;
    const oldScale = camera.scale;
    
    // 改变缩放
    if (e.deltaY > 0) {
        camera.scale *= (1 - zoomSpeed);
    } else {
        camera.scale *= (1 + zoomSpeed);
    }
    camera.scale = Math.max(0.1, Math.min(camera.scale, 100));
    
    // 以鼠标位置为中心缩放：调整相机位置以保持缩放中心
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    const mouseCanvasX = (e.clientX - centerX) / oldScale + camera.x;
    const mouseCanvasY = (e.clientY - centerY) / oldScale + camera.y;
    
    camera.x = mouseCanvasX - (e.clientX - centerX) / camera.scale;
    camera.y = mouseCanvasY - (e.clientY - centerY) / camera.scale;
    
    draw();
}, { passive: false });
function resetState() {
    isPanning = false;
    draggingPoint = null;
    hoveredPoint = null;
    mouse.show = false;
    cvs.style.cursor = 'auto';
    draw();
}
function nearbyVisiblePoint(mx, my) {
    let minDist = getSnapDist();
    let np=null;
    for (const p of points) {
        if(!p.isDefined) continue;
        const d = dist(p, {x: mx, y: my});
        if (d < minDist) {
            minDist = d;
            np = p;
        }
    }
    return np;
}
function findNearestPoint(mx, my) {
    for (const p of points) {
        if (dist(p, {x: mx, y: my}) < getSnapDist()) {
            return p;
        }
    }
    return null;
}
function findNearestIntersection(mx, my) {
    const snapPoints = [];

    // 線與線交點
    for (let i = 0; i < lines.length; i++) {
        for (let j = i + 1; j < lines.length; j++) {
            const inter = intersectLineLine(lines[i], lines[j]);
            if (inter && dist(inter, {x: mx, y: my}) < getSnapDist()) {
                snapPoints.push({
                    point: inter,
                    type: PointType.LINE_LINE,
                    ref: [lines[i], lines[j]],
                    index: 0
                });
            }
        }
    }

    // 圓與圓交點
    for (let i = 0; i < circles.length; i++) {
        for (let j = i + 1; j < circles.length; j++) {
            const inters = intersectCircleCircle(circles[i], circles[j]);
            for (let k = 0; k < inters.length; k++) {
                const p = inters[k];
                if (dist(p, {x: mx, y: my}) < getSnapDist()) {
                    snapPoints.push({
                        point: p,
                        type: PointType.CIRCLE_CIRCLE,
                        ref: [circles[i], circles[j]],
                        index: k
                    });
                }
            }
        }
    }

    // 線與圓交點
    for (let i = 0; i < lines.length; i++) {
        for (let j = 0; j < circles.length; j++) {
            const inters = intersectLineCircle(lines[i], circles[j]);
            for (let k = 0; k < inters.length; k++) {
                const p = inters[k];
                if (dist(p, {x: mx, y: my}) < getSnapDist()) {
                    snapPoints.push({
                        point: p,
                        type: PointType.LINE_CIRCLE,
                        ref: [lines[i], circles[j]],
                        index: k
                    });
                }
            }
        }
    }

    if (snapPoints.length > 0) {
        // 按距離排序，返回最近的
        snapPoints.sort((a, b) => dist(a.point, {x: mx, y: my}) - dist(b.point, {x: mx, y: my}));
        // 構造完整的 Point 對象
        const info = snapPoints[0];
        return new Point(
            info.point.x,
            info.point.y,
            info.type,
            info.ref,
            0,
            info.index
        );
    }

    return null;
}
function pointNearLine(x, y, line) {
    const d = Math.abs(line.A * x + line.B * y + line.C) / Math.hypot(line.A, line.B);
    return d < getSnapDist();
}
function pointNearCircle(x, y, circle) {
    const d = Math.abs(dist({x, y}, circle.center) - circle.r);
    return d < getSnapDist();
}
function findNearestLine(mx, my) {
    for (const l of lines) {
        if (pointNearLine(mx, my, l)) return l;
    }
    return null;
}
function findNearestCircle(mx, my) {
    for (const c of circles) {
        if (pointNearCircle(mx, my, c)) return c;
    }
    return null;
}
function findNearestAny(mx, my) {
    const p = nearbyVisiblePoint(mx, my);
    if (p) return p;
    const l = findNearestLine(mx, my);
    if (l) return l;
    const c = findNearestCircle(mx, my);
    if (c) return c;
    return null;
}
function findExistingLine(p1, p2) {
    // 兩點距離太近無法構成線
    if (dist(p1, p2) < EPS) return null;
    
    return lines.find(l => {
        // 如果 p1 和 p2 都在這條線上，那這條線就是我們要找的
        return pointOnLine(p1, l) && pointOnLine(p2, l);
    });
}
function findExistingCircle(center, p) {
    const radius = dist(center, p);
    // 半徑太小無法構成圓
    if (radius < EPS) return null;

    return circles.find(c => {
        // 圓心相同且半徑相同
        return dist(c.center, center) < EPS && Math.abs(c.r - radius) < EPS;
    });
}
function findExistingPointAt(x, y) {
    return points.find(p => p.isDefined && dist(p, { x, y }) < EPS);
}

function dragPoint(p, mx, my) {
    const snap = new Point(mx, my);

    if (p.type === PointType.FREE) {
        p.x = snap.x;
        p.y = snap.y;
    } else if (p.type === PointType.ON_LINE) {
        const { p1, p2 } = p.ref;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len2 = dx * dx + dy * dy;
        p.t = ((snap.x - p1.x) * dx + (snap.y - p1.y) * dy) / len2;
        p.update();
    } else if (p.type === PointType.ON_CIRCLE) {
        p.t = Math.atan2(snap.y - p.ref.center.y, snap.x - p.ref.center.x);
        p.update();
    }
}
function snapToPoint(x, y) {
    for (const p of points) {
        if (dist({x, y}, p) < getSnapDist()) {
            return {x: p.x, y: p.y}; // 吸附到現有點
        }
    }
    return {x, y}; // 沒有吸附
}
function snapToIntersection(x, y) {
    const snapPoints = [];

    // 所有線與線交點
    for (let i=0;i<lines.length;i++) {
        for (let j=i+1;j<lines.length;j++) {
            const inter = intersectLineLine(lines[i], lines[j]);
            if (inter && dist(inter, {x,y}) < getSnapDist()) snapPoints.push(inter);
        }
    }

    // 所有圓與圓交點
    for (let i=0;i<circles.length;i++) {
        for (let j=i+1;j<circles.length;j++) {
            const inters = intersectCircleCircle(circles[i], circles[j]);
            for (const p of inters) if (dist(p, {x,y}) < getSnapDist()) snapPoints.push(p);
        }
    }

    // 圓與線交點
    for (const c of circles) {
        for (const l of lines) {
            const inters = intersectLineCircle(l, c);
            for (const p of inters) if (dist(p, {x,y}) < getSnapDist()) snapPoints.push(p);
        }
    }

    if (snapPoints.length > 0) {
        // 回傳離滑鼠最近的
        snapPoints.sort((a,b)=>dist(a,{x,y})-dist(b,{x,y}));
        return snapPoints[0];
    }

    return {x,y};
}
function getRank(obj) {
    if (!obj) return 0;
    if (Array.isArray(obj)) {
        return Math.max(...obj.map(o => o.rank || 0));
    }
    return obj.rank || 0;
}

class Point {
    constructor(x, y, type = PointType.FREE, ref = null, t=0,index = 0,visible = true) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.ref = ref;   // 对于交点，ref 是 [line1, line2] 或 [circle1, circle2] 等
        this.t = t; // 用於參數化位置（線上或圓上）
        this.index = index; // 如果有多个交点，用来区分第几个
        this.isDefined = true;
        this.visible = visible;
        this.id = null;
        if (this.type === PointType.FREE) {
            this.rank = 0;
        } else {
            this.rank = getRank(this.ref) + 1;
        }
    }

    update(extraPoints = [], ignoreJump = false, contextOnly = false) {
        const isOccupied = (coord) => {
            if (!contextOnly) {
                const occGlobal = points.some(p => p !== this && p.isDefined && dist(p, coord) < EPS);
                if (occGlobal) return true;
            }
            const occLocal = extraPoints.some(p => p !== this && p.isDefined && dist(p, coord) < EPS);
            return occLocal;
        };

        if (this.type === PointType.ON_LINE) {
            const { p1, p2 } = this.ref;
            this.x = p1.x + this.t * (p2.x - p1.x);
            this.y = p1.y + this.t * (p2.y - p1.y);
        } else if (this.type === PointType.ON_CIRCLE) {
            this.x = this.ref.center.x + this.ref.r * Math.cos(this.t);
            this.y = this.ref.center.y + this.ref.r * Math.sin(this.t);
        } else if (this.type === PointType.LINE_LINE) {
            const [l1, l2] = this.ref;
            const result = intersectLineLine(l1, l2);
            if (result) { this.x = result.x; this.y = result.y; this.isDefined = true; }
            else { this.isDefined = false; }
        } else if (this.type === PointType.CIRCLE_CIRCLE || this.type === PointType.LINE_CIRCLE) {
            const [a, b] = this.ref;
            const results = (this.type === PointType.CIRCLE_CIRCLE) 
                ? intersectCircleCircle(a, b) : intersectLineCircle(a, b);

            if (results.length === 0) {
                this.isDefined = false;
            } else {
                if (this.index >= results.length) this.index = 0;

                if (!ignoreJump && results.length > 1) {
                    const occ0 = isOccupied(results[0]);
                    const occ1 = isOccupied(results[1]);
                    if (this.index === 0 && occ0 && !occ1) this.index = 1;
                    else if (this.index === 1 && occ1 && !occ0) this.index = 0;
                }

                const finalPos = results[this.index];
                if (finalPos) { this.x = finalPos.x; this.y = finalPos.y; this.isDefined = true; }
                else { this.isDefined = false; }
            }
        }
        
        if(this.ref){
            const refs = Array.isArray(this.ref) ? this.ref : [this.ref];
            if (refs.some(r => r && r.isDefined === false)) this.isDefined = false;
        }
    }
}
class Line {
    constructor(p1, p2, visible = true) {
        // Ax + By + C = 0
        this.p1 = p1;
        this.p2 = p2;
        this.id = null;
        this.isDefined = true;
        this.rank = Math.max(p1.rank, p2.rank) + 1;
        this.visible = visible;
    }
    
    get A() {
        return this.p2.y - this.p1.y;
    }
    
    get B() {
        return this.p1.x - this.p2.x;
    }
    
    get C() {
        return -(this.A * this.p1.x + this.B * this.p1.y);
    }
    update() {
        if (!this.p1.isDefined || !this.p2.isDefined) {
            this.isDefined = false;
        } else {
            this.isDefined = true;
        }
    }
}
class Circle {
    constructor(center, p, visible = true) {
        this.center = center;
        this.p = p;
        this.id = null;
        this.isDefined = true;
        this.rank = Math.max(center.rank, p.rank) + 1;
        this.visible = visible;
    }
    get r() {
        return dist(this.center, this.p);
    }
    update() {
        if (!this.center.isDefined || !this.p.isDefined) {
            this.isDefined = false;
        } else {
            this.isDefined = true;
        }
    }
}

function getAllAncestors(obj, ancestors = new Set()) {
    if (!obj || ancestors.has(obj)) return ancestors;
    
    let parents = [];
    if (obj instanceof Line) parents = [obj.p1, obj.p2];
    else if (obj instanceof Circle) parents = [obj.center, obj.p];
    else if (obj instanceof Point && obj.ref) {
        parents = Array.isArray(obj.ref) ? obj.ref : [obj.ref];
    }

    parents.forEach(p => {
        ancestors.add(p);
        getAllAncestors(p, ancestors);
    });
    return ancestors;
}
function validateOutput(output, inputs) {
    const availableIds = new Set();
    
    // 将所有输入对象及其“物理组件”加入可用清单
    inputs.forEach(i => {
        availableIds.add(i.id);
        if (i instanceof Line) {
            availableIds.add(i.p1.id);
            availableIds.add(i.p2.id);
        } else if (i instanceof Circle) {
            availableIds.add(i.center.id);
            availableIds.add(i.p.id);
        }
    });

    if (output instanceof Point && output.type === PointType.FREE) {
        return false; 
    }

    const ancestors = getAllAncestors(output);
    for (let ancestor of ancestors) {
        // 如果祖先是一个自由点，它必须在“可用清单”中（或者是输入本身，或者是输入的端点/圆心）
        if (ancestor instanceof Point && ancestor.type === PointType.FREE) {
            if (!availableIds.has(ancestor.id)) return false;
        }
    }
    return true;
}
function isInputRedundant(newInput, existingInputs) {
    for (let input of existingInputs) {
        if (input === newInput) return true;
    }
    return false; 
}
function getMacroSteps(outputs, inputs) {
    const steps = [];
    const visited = new Set();
    const outputIds = new Set(outputs.map(o => o.id)); // 記錄哪些 ID 是最終輸出的物件
    
    inputs.forEach(o => {
        visited.add(o.id);
        if (o instanceof Line) {
            visited.add(o.p1.id);
            visited.add(o.p2.id);
        }
        if (o instanceof Circle) {
            visited.add(o.center.id);
            visited.add(o.p.id);
        }
    });

    function trace(obj) {
        if (!obj || visited.has(obj.id)) return;
        
        let parents = [];
        if (obj instanceof Line) parents = [obj.p1, obj.p2];
        else if (obj instanceof Circle) parents = [obj.center, obj.p];
        else if (obj instanceof Point && obj.ref) {
            parents = Array.isArray(obj.ref) ? obj.ref : [obj.ref];
        }

        parents.forEach(p => trace(p));

        if (!visited.has(obj.id)) {
            visited.add(obj.id);
            const stepData = serializeObject(obj);
            stepData.isOutput = outputIds.has(obj.id); 
            steps.push(stepData);
        }
    }

    outputs.forEach(o => trace(o));
    return steps;
}
function serializeObject(obj) {
    const data = {
        id: obj.id,
        className: obj.constructor.name,
        type: obj.type ? obj.type.name : null,
        t: obj.t || 0,
        index: obj.index || 0
    };
    if (obj instanceof Line) {
        data.parents = [obj.p1.id, obj.p2.id];
        data.sub = [obj.p1.id, obj.p2.id];
    }
    if (obj instanceof Circle) {
        data.parents = [obj.center.id, obj.p.id];
        data.sub = [obj.center.id, obj.p.id];
    }
    if (obj instanceof Point && obj.ref) {
        data.parents = Array.isArray(obj.ref) ? obj.ref.map(r => r.id) : [obj.ref.id];
    }
    return data;
}
function runTool(toolData, currentSelectedObjects) {
    const idMap = new Map();
    const macroInternalPoints = [];

    toolData.inputs.forEach((inputInfo, i) => {
        const realObj = currentSelectedObjects[i];
        idMap.set(inputInfo.id, realObj);
        if (realObj instanceof Point) macroInternalPoints.push(realObj);
        else if (realObj instanceof Line) {
            idMap.set(inputInfo.sub[0], realObj.p1);
            idMap.set(inputInfo.sub[1], realObj.p2);
            macroInternalPoints.push(realObj.p1, realObj.p2);
        } else if (realObj instanceof Circle) {
            idMap.set(inputInfo.sub[0], realObj.center);
            idMap.set(inputInfo.sub[1], realObj.p);
            macroInternalPoints.push(realObj.center, realObj.p);
        }
    });

    toolData.steps.forEach(step => {
        const parents = step.parents.map(pid => idMap.get(pid));
        let finalRealObj = null;
        
        const isVisible = step.isOutput === true;

        if (step.className === "Point") {
            const typeObj = Object.values(PointType).find(t => t.name === step.type);
            const ref = parents.length > 1 ? parents : parents[0];
            
            let p = new Point(0, 0, typeObj, ref, step.t || 0, step.index || 0, isVisible);
            p.update(macroInternalPoints, false, true); 

            let existing = findExistingPointAt(p.x, p.y);
            if (existing) {
                finalRealObj = existing;
                if (isVisible) finalRealObj.visible = true;
            } else {
                finalRealObj = p;
                points.push(finalRealObj);
                recordAction(finalRealObj, points);
            }
            macroInternalPoints.push(finalRealObj);
        } 
        else if (step.className === "Line") {
            finalRealObj = findExistingLine(parents[0], parents[1]);
            if (!finalRealObj) {
                finalRealObj = new Line(parents[0], parents[1], isVisible);
                lines.push(finalRealObj);
                recordAction(finalRealObj, lines);
            } else if (isVisible) {
                finalRealObj.visible = true;
            }
        } 
        else if (step.className === "Circle") {
            finalRealObj = findExistingCircle(parents[0], parents[1]);
            if (!finalRealObj) {
                finalRealObj = new Circle(parents[0], parents[1], isVisible);
                circles.push(finalRealObj);
                recordAction(finalRealObj, circles);
            } else if (isVisible) {
                finalRealObj.visible = true;
            }
        }
        
        if (finalRealObj) idMap.set(step.id, finalRealObj);
    });

    draw();
}
function getAllObjectsSorted() {
    const all = [...points, ...lines, ...circles];
    return all.sort((a, b) => a.rank - b.rank);
}
function updateAll() {
    const sortedObjects = getAllObjectsSorted();
    for (const obj of sortedObjects) {
        obj.update();
    }
}

function dist(p, q) {
    return Math.hypot(p.x - q.x, p.y - q.y);
}
function $(el) {
    return document.querySelector(el);
}
function DegToRad(a) {
    return a * Math.PI / 180;
}
function random(a, b) {
    return Math.floor(Math.random() * (b - a + 1)) + a;
}
function HSLToRGB(h, s, l) {
    s /= 100;
    l /= 100;
    let c = (1 - Math.abs(2 * l - 1)) * s,
        x = c * (1 - Math.abs((h / 60) % 2 - 1)),
        m = l - c / 2,
        r = 0,
        g = 0,
        b = 0;
    if (0 <= h && h < 60) {
        r = c; g = x; b = 0;
    } else if (60 <= h && h < 120) {
        r = x; g = c; b = 0;
    } else if (120 <= h && h < 180) {
        r = 0; g = c; b = x;
    } else if (180 <= h && h < 240) {
        r = 0; g = x; b = c;
    } else if (240 <= h && h < 300) {
        r = x; g = 0; b = c;
    } else if (300 <= h && h < 360) {
        r = c; g = 0; b = x;
    }
    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);

    return "rgb(" + r + "," + g + "," + b + ")";
}

function createFreePoint(mx, my) {
    const snap = snapToPoint(mx, my);
    const p = new Point(snap.x, snap.y, PointType.FREE);
    points.push(p);
    recordAction(p, points);
    return p;
}
function createPointOnLine(line, mx, my) {
    const { p1, p2 } = line;
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const len2 = dx * dx + dy * dy;
    
    const t = ((mx - p1.x) * dx + (my - p1.y) * dy) / len2;
    
    const p = new Point(0, 0, PointType.ON_LINE, line, t);
    p.update();
    points.push(p);
    recordAction(p, points);
    return p;
}
function createPointOnCircle(circle, mx, my) {
    const angle = Math.atan2(my - circle.center.y, mx - circle.center.x);
    const p = new Point(0, 0, PointType.ON_CIRCLE, circle, angle);
    p.update();
    points.push(p);
    recordAction(p, points);
    return p;
}

function intersectCircleCircle(c0, c1) {
    const x0 = c0.center.x, y0 = c0.center.y;
    const x1 = c1.center.x, y1 = c1.center.y;
    const r0 = c0.r, r1 = c1.r;

    const dx = x1 - x0;
    const dy = y1 - y0;
    const d = Math.hypot(dx, dy);

    // 無交點
    if (d > r0 + r1 + EPS) return [];
    if (d < Math.abs(r0 - r1) - EPS) return [];
    if (d < EPS && Math.abs(r0 - r1) < EPS) {
        // 重合（通常不處理）
        return [];
    }

    // a = 到交點連線投影長
    const a = (r0 * r0 - r1 * r1 + d * d) / (2 * d);

    // h = 垂直高度
    const h2 = r0 * r0 - a * a;
    const h = Math.sqrt(Math.max(0, h2));

    // 中點
    const xm = x0 + a * dx / d;
    const ym = y0 + a * dy / d;

    // 偏移向量
    const rx = -dy * (h / d);
    const ry = dx * (h / d);

    const p1 = { x: xm + rx, y: ym + ry };
    const p2 = { x: xm - rx, y: ym - ry };

    // 切線（h ≈ 0）
    if (h < EPS) return uniquePoints(h < EPS ? [p1] : [p1, p2]);

    return [p1, p2];
}
function intersectLineLine(l1, l2) {
    const D = l1.A * l2.B - l2.A * l1.B;
    if (Math.abs(D) < EPS) return null;

    const x = (l1.B * l2.C - l2.B * l1.C) / D;
    const y = (l2.A * l1.C - l1.A * l2.C) / D;
    return new Point(x, y);
}
function intersectLineCircle(line, circle) {
    // 投影法（穩定）
    const { A, B, C } = line;
    const { x: x0, y: y0 } = circle.center;

    const d = Math.abs(A * x0 + B * y0 + C) / Math.hypot(A, B);
    if (d > circle.r + EPS) return [];

    const t = -(A * x0 + B * y0 + C) / (A * A + B * B);
    const x = x0 + A * t;
    const y = y0 + B * t;

    const h = Math.sqrt(Math.max(0, circle.r ** 2 - d ** 2));
    const vx = -B / Math.hypot(A, B);
    const vy = A / Math.hypot(A, B);

    if (h < EPS) {
    return [new Point(x, y)];
    }

    return [
        new Point(x + vx * h, y + vy * h),
        new Point(x - vx * h, y - vy * h)
    ];
}
function pointOnLine(p, line) {
    return Math.abs(line.A * p.x + line.B * p.y + line.C)
        / Math.hypot(line.A, line.B) < EPS;
}
function pointOnCircle(p, c) {
  return Math.abs(dist(p, c.center) - c.r) < EPS;
}
function equalLength(p1, p2, p3, p4) {
    return Math.abs(dist(p1, p2) - dist(p3, p4)) < EPS;
}
function dot(l1, l2) {
    return l1.A * l2.A + l1.B * l2.B;
}
function perpendicular(l1, l2) {
    return Math.abs(dot(l1, l2)) < EPS;
}
function parallel(l1, l2) {
    return Math.abs(l1.A * l2.B - l2.A * l1.B) < EPS;
}
function uniquePoints(points) {
    const res = [];
    for (const p of points) {
        if (!res.some(q => dist(p, q) < EPS)) {
            res.push(p);
        }
    }
    return res;
}
function stickTo(mx,my){

    // 優先順序：1. 現有的點 2. 交點 3. 線上/圓上的投影點 4. 自由點
    let pPos = null;

    if (hoveredPoint) {
        // 1. 吸附到現有的點
        pPos = { x: hoveredPoint.x, y: hoveredPoint.y };
    } else {
        const intersection = findNearestIntersection(mx, my);
        const clr="#f00";
        if (intersection) {
            // 2. 吸附到交點
            pPos = { x: intersection.x, y: intersection.y };
            if(intersection.type === PointType.LINE_LINE){
                const [l1, l2] = intersection.ref;
                drawLine(l1, clr);
                drawLine(l2, clr);
            }else if(intersection.type === PointType.CIRCLE_CIRCLE){
                const [c1, c2] = intersection.ref;
                drawCircle(c1, clr);
                drawCircle(c2, clr);
            }else if(intersection.type === PointType.LINE_CIRCLE){
                const [l, c] = intersection.ref;
                drawLine(l, clr);
                drawCircle(c, clr);
            }
        } else {
            // 3. 檢查是否在線段上
            let foundOnGeometry = false;
            for (const line of lines) {
                if (pointNearLine(mx, my, line)) {
                    const { p1, p2 } = line;
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const len2 = dx * dx + dy * dy;
                    const t = ((mx - p1.x) * dx + (my - p1.y) * dy) / len2;
                    pPos = {
                        x: p1.x + t * dx,
                        y: p1.y + t * dy
                    };
                    foundOnGeometry = true;
                    drawLine(line, clr);
                    break;
                }
            }
            
            // 4. 檢查是否在圓形上 (如果沒在線上)
            if (!foundOnGeometry) {
                for (const circle of circles) {
                    if (pointNearCircle(mx, my, circle)) {
                        const angle = Math.atan2(my - circle.center.y, mx - circle.center.x);
                        pPos = {
                            x: circle.center.x + circle.r * Math.cos(angle),
                            y: circle.center.y + circle.r * Math.sin(angle)
                        };
                        foundOnGeometry = true;
                        drawCircle(circle, clr);
                        break;
                    }
                }
            }

            // 5. 都沒有，就是自由點
            if (!foundOnGeometry) {
                pPos = { x: mx, y: my };
            }
        }
    }
    return pPos;
}

function drawPoint(p,clr="#f0f") {
    if(!p.isDefined) return;
    ctx.beginPath();
    ctx.arc(p.x, p.y, BASE_POINT_RADIUS*0.8/camera.scale, 0, Math.PI*2);
    ctx.fillStyle = clr;
    ctx.strokeStyle = "#000";
    ctx.lineWidth=1/camera.scale;
    ctx.fill();
    ctx.stroke();
}
function drawLine(line, style = "#0f0") {
    if(!line.isDefined) return;
    const p1 = line.p1;
    const p2 = line.p2;
    
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const len = Math.hypot(dx, dy);

    const ux = dx / len;
    const uy = dy / len;
    
    const viewW = window.innerWidth / camera.scale;
    const viewH = window.innerHeight / camera.scale;
    const screenDiagonal = Math.hypot(viewW, viewH);
    
    const distToCamera = Math.hypot(p1.x - camera.x, p1.y - camera.y);
    
    const t_large = distToCamera + screenDiagonal;
    
    const x1 = p1.x - ux * t_large;
    const y1 = p1.y - uy * t_large;
    const x2 = p1.x + ux * t_large;
    const y2 = p1.y + uy * t_large;
    
    ctx.save();
    ctx.strokeStyle = style;
    ctx.lineWidth = 3 * (1 + isMobile * 0.3) / camera.scale;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
}
function drawCircle(circle, style = "#0ff") {
    if(!circle.isDefined) return;
    ctx.strokeStyle = style;
    ctx.lineWidth = 3*(1+isMobile*0.3)/camera.scale;
    ctx.beginPath();
    ctx.arc(circle.center.x, circle.center.y, dist(circle.center, circle.p), 0, Math.PI * 2);
    ctx.stroke();
}
function highlightObj(obj, color) {
    ctx.save();
    ctx.shadowBlur = 15;
    ctx.shadowColor = color;
    if (obj instanceof Point) drawPoint(obj, color);
    if (obj instanceof Line) drawLine(obj, color);
    if (obj instanceof Circle) drawCircle(obj, color);
    ctx.restore();
}
function draw() {
    bk();
    ctx.save();
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    ctx.translate(centerX, centerY);
    ctx.scale(camera.scale, camera.scale);
    ctx.translate(-camera.x, -camera.y);

    updateAll();

    for (const l of lines){
        if(l.visible==false){
            drawLine(l, (mode === Mode.HIDE) ? "#444" : "#222");
            continue;
        }
        drawLine(l);
    }
    for (const c of circles){
        if(c.visible==false){
            drawCircle(c, (mode === Mode.HIDE) ? "#444" : "#222");
            continue;
        }
        drawCircle(c);
    }

    if(mode===Mode.MOVE&&highlightedObject){
        const obj=highlightedObject;
        if(obj instanceof Line){
            highlightObj(obj, "#ffff00");
            highlightObj(obj.p1, "#ffff00");
            highlightObj(obj.p2, "#ffff00");
        }
        if(obj instanceof Circle){
            highlightObj(obj, "#ffff00");
            highlightObj(obj.center, "#ffff00");
            highlightObj(obj.p, "#ffff00");
        }
    }

    if(mouse.show&&!isPanning){
        if(selectedPoint){
            const mousePoint = stickTo(mouse.x, mouse.y);
            ctx.save();
            ctx.setLineDash([5 / camera.scale, 5 / camera.scale]);
            const clr="#fff8";
            if(dist(selectedPoint, mousePoint)>BASE_SNAP_DIST){
                if(mode === Mode.LINE){
                    drawLine(new Line(selectedPoint, mousePoint), clr);
                } else if(mode === Mode.CIRCLE){
                    drawCircle(new Circle(selectedPoint, mousePoint), clr);
                }
            }
            ctx.restore();
        }
        if(mode === Mode.POINT&&!isMultiTouch) {
            const mx = mouse.x;
            const my = mouse.y;
            
            const pPos = stickTo(mx, my);

            const previewRadius = isMobile ? BASE_SNAP_DIST * 1.2 : BASE_SNAP_DIST * 0.8;
            ctx.beginPath();
            ctx.arc(pPos.x, pPos.y, previewRadius / camera.scale, 0, Math.PI * 2);
            ctx.fillStyle = "#fff8";
            ctx.fill();
        }
        if((mode === Mode.CIRCLE||mode === Mode.LINE)&&!isMultiTouch&&selectedPoint) {
            const mx = mouse.x;
            const my = mouse.y;
            
            const pPos = stickTo(mx, my);

            const previewRadius = isMobile ? BASE_SNAP_DIST * 1.2 : BASE_SNAP_DIST * 0.8;
            ctx.beginPath();
            ctx.arc(pPos.x, pPos.y, previewRadius / camera.scale, 0, Math.PI * 2);
            ctx.fillStyle = "#fff8";
            ctx.fill();
        }
    }
    if (draggingPoint) {
        if(draggingPoint.type.dof>0){
            circles.forEach(c=>{
                if(c.center===draggingPoint||c.p===draggingPoint){
                    highlightObj(c, "#ffffff");
                }
            });
            lines.forEach(l=>{
                if(l.p1===draggingPoint||l.p2===draggingPoint){
                    highlightObj(l, "#ffffff");
                }
            });
        }
    }
    // 繪製所有點
    for (const p of points){
        if(p.visible==false){
            drawPoint(p, "#333");
            continue;
        }
        if(p.type.dof==2){
            drawPoint(p, "#ff00ff");
        }else if(p.type.dof==1){
            drawPoint(p, "#800");
        }else{
            drawPoint(p, "#00f");
        }
    }
    
    // 繪製懸停點的 highlight
    if (hoveredPoint) {
        drawPoint(hoveredPoint, "#ffff00");
    }
    
    // 繪製已選中點的 highlight
    if (selectedPoint) {
        drawPoint(selectedPoint, "#ff5500");
    }

    // 繪製拖曳中點的 highlight
    if (draggingPoint) {
        if(draggingPoint.type.dof>0){
            highlightObj(draggingPoint, "#ffffff");
        }
    }
    const fontSize=20*dpr;
    const fontStyle=`bold ${fontSize}px Arial`;
    if (mode === Mode.MACRO_DEFINE) {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = "#00ffbf";
        ctx.font = fontStyle;
        ctx.fillText(`Inputs: ${macroCreator.inputs.length} | Outputs: ${macroCreator.outputs.length}`, 20, window.innerHeight*dpr - fontSize*1.2-30);
        ctx.restore();
        
        macroCreator.inputs.forEach(o => highlightObj(o, "#00ffbf"));
        macroCreator.outputs.forEach(o => highlightObj(o, "#ff5500"));
    }
    if (mode === Mode.MACRO_EXECUTE && activeTool) {
        const currentIndex = macroSelection.length;
        
        // 只有在還沒選滿時，才去讀取「下一個預期物件」的資料
        if (currentIndex < activeTool.inputs.length) {
            const expected = activeTool.inputs[currentIndex];
            const outputType = expected.className;
            
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.fillStyle = "#00ffbf";
            ctx.font = fontStyle;
            ctx.fillText(`Step ${currentIndex + 1}/${activeTool.inputs.length}: Select a ${outputType}`, 20, window.innerHeight * dpr - fontSize*1.2-30);
            ctx.restore();
        }
        
        // 繪製已經選中的高亮
        macroSelection.forEach(o => highlightObj(o, "#00ffbf"));
    }
    
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0); 
    ctx.fillStyle = "#888";
    ctx.font = fontStyle;
    ctx.fillText(`Points: ${points.length} | Lines: ${lines.length} | Circles: ${circles.length}`, 20, window.innerHeight * dpr - 30);
    ctx.restore();

    ctx.restore();

    let gdt = ctx.createLinearGradient(0, 0, window.innerWidth, window.innerHeight);
    gdt.addColorStop(1, "#f00");
    gdt.addColorStop(0, "#f0f");
    ctx.strokeStyle = gdt;
    ctx.lineWidth = 10;
    ctx.strokeRect(0, 0, window.innerWidth, window.innerHeight);
    
}
function bk() {
    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    ctx.save();
    ctx.fillStyle = "#181818";
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
    ctx.restore();
}
draw();
setMode(mode);
updateHistoryButtons();
</script>
</body>

</html>