<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>draw (Wasm Powered)</title>
    <style>
        body { -webkit-user-select: none; -moz-user-select: none; user-select: none; font-size: 30px; }
        .qw { width: 50px; display: none; }
        .qe { color: white; display: none; }
        .cc { display: none; }
        #a1 { min-width: 300px; image-rendering: pixelated; }
        input[type="range"] { width: 200px; }
    </style>
</head>

<body style="background-color:black;color:yellow">
    <canvas id="a1" width=1 height=1 style="border: 1px solid #fff;background-color:white;touch-action: none;"></canvas>
    <br>
    <span id="b1" style="font-size:15px;color:white;">x:0</span>
    <span id="b2" style="font-size:15px;color:white;">y:0</span>
    <span id="b3" style="font-size:15px;color:white;"></span>
    <br>
    顏色:<input id="a2" type="color">
    透明度:<input id="a3" type="range" min=1 max=255 step=1>
    <span id="b4" style="font-size:15px;color:white;">255</span>
    <br>
    容差:<input id="a5" type="range" min=1 max=255 step=1>
    <span id="b5" style="font-size:15px;color:white;">10</span>
    <br>
    大小:<input id="a6" type="range" min=1 max=100 step=1>
    <span id="b6" style="font-size:15px;color:white;">1</span>
    <br>
    修改畫布:
    <br>
    背景色:<input id="a4" type="color">
    <br>
    <input type="file" name="fl" id="ed" accept="image/*" onchange="window.loadFile(event)">
    <br>
    x:<input id="ax" type="number" style="width:50px;">
    y:<input id="ay" type="number" style="width:50px;">
    <button onclick="window.qz()">Change!</button>
    <br>
    <br class="cc">
    <span class="qe">走迷宮:</span>
    <br class="cc">
    <span class="qe" style="width:60px;">start </span>
    <span class="qe">x:</span>
    <input id="c1" type="number" class="qw">
    <span class="qe">y:</span>
    <input id="c2" type="number" class="qw">
    <button class="cc" onclick="window.qr()">Go!</button>
    <br class="cc">
    <span class="qe" style="width:60px;">end </span>
    <span class="qe">x:</span>
    <input id="c3" type="number" class="qw">
    <span class="qe">y:</span>
    <input id="c4" type="number" class="qw">
    <button class="cc" onclick="window.qd()">cls</button>
    <br class="cc">
    <span id="cq" class="qe">q:走法(1)</span>
    <br class="cc">
    <span class="qe">cr:</span>
    <input id="c5" class="qw" type="color" value="#ff0000">
    <pre>
圖片上點右鍵可存檔!
a:走迷宮
b:酷
c:清除歷史
e:橡皮擦
f:清空
h:上下對稱
i:左右對稱
j:中心對稱
k:上下+左右對稱
l:旋轉對稱
m:8方位對稱
p:自動生成迷宮
v:倒汁
z:復原
y:取消復原
</pre>

    <script type="module">
         import init, { wasm_flood_fill, wasm_find_path, wasm_generate_maze } from './pkg/mirage_wasm.js';

        // --- 變數定義 ---
        var a1 = document.getElementById("a1"), a2 = document.getElementById("a2"), a3 = document.getElementById("a3"),
            a4 = document.getElementById("a4"), a5 = document.getElementById("a5"), a6 = document.getElementById("a6"),
            ax = document.getElementById("ax"), ay = document.getElementById("ay"), b1 = document.getElementById("b1"),
            b2 = document.getElementById("b2"), b4 = document.getElementById("b4"), b5 = document.getElementById("b5"), 
            b6 = document.getElementById("b6"), c1 = document.getElementById("c1"), c2 = document.getElementById("c2"), 
            c3 = document.getElementById("c3"), c4 = document.getElementById("c4"), c5 = document.getElementById("c5"), 
            cq = document.getElementById("cq");
        var qw = document.querySelectorAll('.qw'), qe = document.querySelectorAll('.qe'), cc = document.querySelectorAll('.cc');
        var ctx = a1.getContext("2d", { willReadFrequently: true });
        
        var qo = 1, qo1 = 0, step = -1, hist = [], qqe = 0, ti = 0, ww = 1, q = 1, isMouseDown = false, ea = 1, va = 0, ma = 0;
        var rgb1r = 0, rgb1g = 0, rgb1b = 0, rgb1a = 255, xx = -1, yy = -1, wx = [], wy = [], wz = 0, qa = 0, sx, sy, weq = 0, tol = 10;
        var lastDrawX = null, lastDrawY = null;

        // 初始化 Wasm
        async function runWasm() {
            await init();
            console.log("Wasm Ready");
            window.qz = qz;
            window.qr = qr_wasm;
            window.qd = qd;
            window.wea = wea_wasm;
            window.loadFile = loadFile;
        }
        runWasm();

        // --- 核心 Wasm 提升功能 ---

        // 1. 倒汁 (Flood Fill)
        function qtw_wasm(x, y) {
            let imgData = ctx.getImageData(0, 0, a1.width, a1.height);
            const result = wasm_flood_fill(
                new Uint8Array(imgData.data), a1.width, a1.height,
                Math.floor(x), Math.floor(y),
                rgb1r, rgb1g, rgb1b, rgb1a, parseInt(tol)
            );
            imgData.data.set(result);
            ctx.putImageData(imgData, 0, 0);
            ww = 1;
            psh(); // 倒汁後存檔
        }

        // 2. 走迷宮 (Pathfinding)
        function qr_wasm() {
            if (!c1.value || !c2.value || !c3.value || !c4.value) return;
            let imgData = ctx.getImageData(0, 0, a1.width, a1.height);
            let path = wasm_find_path(
                imgData.data, a1.width, a1.height,
                parseInt(c3.value), parseInt(c4.value),
                parseInt(c1.value), parseInt(c2.value), qa
            );
            if (path.length > 0) {
                // 備份狀態
                let r1 = rgb1r, g1 = rgb1g, b1 = rgb1b, a1_v = rgb1a, e1 = ea;
                ea = 1; rgb1a = 255;
                rgb1r = parseInt(c5.value.substr(1, 2), 16);
                rgb1g = parseInt(c5.value.substr(3, 2), 16);
                rgb1b = parseInt(c5.value.substr(5, 2), 16);
                
                wx = []; wy = [];
                // 每一步都繪製並存檔 (應要求)
                for (let i = 0; i < path.length; i += 2) {
                    let px = path[i];
                    let py = path[i+1];
                    df(px, py, 0);
                    wx.push(px); wy.push(py);
                    psh(); // 每一步都存檔到歷史
                }
                
                ea = e1; rgb1r = r1; rgb1g = g1; rgb1b = b1; rgb1a = a1_v;
                wz = 1;
            } else { alert("路不通"); }
        }

        // 3. 生成迷宮 (Maze Gen)
        function wea_wasm() {
            ctx.clearRect(0, 0, a1.width, a1.height);
            let maze = wasm_generate_maze(sx, sy);
            let ew = ea; ea = 1;
            for (let i = 0; i < sy; i++) {
                for (let j = 0; j < sx; j++) {
                    if (maze[i * sx + j] === 0) df(j, i, 0);
                }
            }
            ea = ew;
            psh();
        }

        function qt() {
            var ste = step;
            step = 0;
            qo = 0;
            qt1(ste);
        }
        function qt1(ste) {
            setTimeout(() => {
                if (step == ste || step == hist.length - 1) {
                    qo = 1;
                    return;
                }
                undo(1);
                if (qo1 == 1) { // 快速播放邏輯
                    qo1 = 2;
                    while (!(step == ste || step == hist.length - 1)) step++;
                    step--;
                    undo(1);
                    qo = 1;
                    return;
                }
                qt1(ste);
            }, 10);
        }
        // --- 保留原本所有的輔助函式與邏輯 ---
        const dbName = location.href;
        const storeName = 'img';
        let db;
        const openRequest = indexedDB.open(dbName, 1);
        openRequest.onupgradeneeded = (e) => {
            db = e.target.result;
            if (!db.objectStoreNames.contains(storeName)) db.createObjectStore(storeName, { keyPath: 'id' });
        };
        openRequest.onsuccess = (e) => { db = e.target.result; loadTextareaContent(); };

        function saveimg() {
            if (!db) return;
            const transaction = db.transaction([storeName], 'readwrite');
            transaction.objectStore(storeName).put({
                id: 1, img: a1.toDataURL(), bgclr: a4.value, clr: a2.value, q: q, tol: tol,
            });
        }

        function loadTextareaContent() {
            const request = db.transaction([storeName], 'readonly').objectStore(storeName).get(1);
            request.onsuccess = (event) => {
                if (event.target.result) {
                    const data = event.target.result;
                    a4.value = data.bgclr; a2.value = data.clr;
                    rgb1r = parseInt(a2.value.substr(1,2),16); rgb1g = parseInt(a2.value.substr(3,2),16); rgb1b = parseInt(a2.value.substr(5,2),16);
                    q = data.q; tol = data.tol; a5.value = tol; b5.textContent = tol; a6.value = q; b6.textContent = q;
                    a1.style["background-color"] = data.bgclr;
                    let lastDraw = new Image; lastDraw.src = data.img;
                    lastDraw.onload = () => {
                        sx = lastDraw.width / q; sy = lastDraw.height / q;
                        a1.width = lastDraw.width; a1.height = lastDraw.height;
                        ctx.drawImage(lastDraw, 0, 0); psh();
                    };
                } else { sx = 50; sy = 50; a1.width = sx * q; a1.height = sy * q; psh(); }
            };
        }

        function psh() {
            const cur = a1.toDataURL();
            if (hist.length > 0 && hist[step] === cur) return;
            step++;
            if (step < hist.length) hist.length = step;
            hist.push(cur);
            saveimg();
        }

        function undo(qq) {
            if (qq == -1 && step <= 0) return;
            if (qq == 1 && step >= hist.length - 1) return;
            step += qq;
            let lastDraw = new Image; lastDraw.src = hist[step];
            lastDraw.onload = () => {
                ctx.clearRect(0, 0, a1.width, a1.height);
                ctx.drawImage(lastDraw, 0, 0);
                saveimg();
            };
        }

        function df(x, y, sym) {
            if (sym) {
                if (ma == 1) df(x, sy - 1 - y, 0);
                if (ma == 2) df(sx - 1 - x, y, 0);
                if (ma == 3) df(sx - 1 - x, sy - 1 - y, 0);
                if (ma == 4) { df(x, sy - 1 - y, 0); df(sx - 1 - x, y, 0); df(sx - 1 - x, sy - 1 - y, 0); }
                if (ma == 5) { df(sy - 1 - y, x, 0); df(y, sx - 1 - x, 0); df(sx - 1 - x, sy - 1 - y, 0); }
                if (ma == 6) { df(x, sy - 1 - y, 0); df(sx - 1 - x, y, 0); df(sx - 1 - x, sy - 1 - y, 0); df(y, x, 0); df(sy - 1 - y, x, 0); df(y, sx - 1 - x, 0); df(sy - 1 - y, sx - 1 - x, 0); }
            }
            if (ea) {
                ctx.fillStyle = `rgba(${rgb1r},${rgb1g},${rgb1b},${rgb1a/255})`;
                ctx.fillRect(x * q, y * q, q, q);
            } else {
                ctx.clearRect(x * q, y * q, q, q);
            }
        }

        function af(x, y, ex, ey) {
            if (x == xx && y == yy && !va) return;
            xx = x; yy = y;
            if (va) {
                if (ww) { ww = 0; qtw_wasm(ex, ey); }
            } else {
                df(x, y, 1);
            }
        }

        function srgba(x, y) { return ctx.getImageData(x * q, y * q, 1, 1).data; }

        // --- 事件綁定 ---
        a1.addEventListener("mousedown", () => { isMouseDown = true; ti = 1; });
        a1.addEventListener("touchstart", () => { isMouseDown = true; ti = 1; });
        document.addEventListener("mouseup", () => { isMouseDown = false; setTimeout(() => ti = 0, 100); psh(); });
        document.addEventListener("touchend", () => { isMouseDown = false; setTimeout(() => ti = 0, 100); psh(); });

        a1.addEventListener("mousemove", (e) => {
            let x = e.offsetX, y = e.offsetY;
            let tj = a1.width / a1.clientWidth; x *= tj; y *= tj;
            let gx = Math.floor(x / q), gy = Math.floor(y / q);
            b1.textContent = 'x:' + gx; b2.textContent = 'y:' + gy;
            if (isMouseDown) {
                if (lastDrawX !== null) {
                    let dx = gx - lastDrawX, dy = gy - lastDrawY;
                    let steps = Math.max(Math.abs(dx), Math.abs(dy));
                    for (let i = 0; i <= steps; i++) af(Math.round(lastDrawX + dx * i / steps), Math.round(lastDrawY + dy * i / steps), x, y);
                } else af(gx, gy, x, y);
                lastDrawX = gx; lastDrawY = gy;
            } else lastDrawX = null;
        });

        a1.onclick = (e) => {
            let x = e.offsetX * (a1.width / a1.clientWidth), y = e.offsetY * (a1.width / a1.clientWidth);
            af(Math.floor(x / q), Math.floor(y / q), x, y);
        };

        // UI 連動
        a2.onchange = () => { rgb1r = parseInt(a2.value.substr(1,2),16); rgb1g = parseInt(a2.value.substr(3,2),16); rgb1b = parseInt(a2.value.substr(5,2),16); saveimg(); };
        a3.oninput = () => { rgb1a = a3.value; b4.textContent = a3.value; };
        a5.oninput = () => { tol = a5.value; b5.textContent = tol; };
        a6.oninput = () => { q = a6.value; b6.textContent = q; };
        a4.oninput = () => a1.style["background-color"] = a4.value;

        // 鍵盤
        document.body.onkeydown = (k) => {
            if (k.key == 'a') { weq ^= 1; let d = weq ? "inline-block" : "none"; qw.forEach(e=>e.style.display=d); qe.forEach(e=>e.style.display=d); cc.forEach(e=>e.style.display=d); }
            if (k.key == 'b') { if (qo == 0) { if (qo1 == 1) qo1 = 2; else qo1 = 1; return; } qo1 = 0; qt(); }
            if (k.key == 'c') { if (qo == 0) return; step = -1; hist = []; psh(); }
            if (k.key == 'e') { ea ^= 1; }
            if (k.key == 'f') { if (qo == 0) return; ctx.clearRect(0,0,a1.width,a1.height); psh(); }
            if (k.key == 'v') va ^= 1;
            if (k.key == 'z') { if (qo == 0) return; undo(-1); }
            if (k.key == 'y') { if (qo == 0) return; undo(1); }
            if (k.key == 'p') { if (qo == 0) return; window.wea(); }
            if (k.key == 'q') { qa = (qa + 1) % 3; cq.textContent = "q:走法(" + (qa + 1) + ")"; }
            // 對稱快捷鍵
            if (['h','i','j','k','l','m'].includes(k.key)) {
                let map = {h:1, i:2, j:3, k:4, l:5, m:6};
                ma = (ma == map[k.key] ? 0 : map[k.key]);
            }
        };

        function qz() { sx = parseInt(ax.value); sy = parseInt(ay.value); a1.width = sx * q; a1.height = sy * q; psh(); }
        function qd() {
            if (wz) { // wz 是標記「目前是否有路徑存在」的變數
                var we = ea; // 備份目前的畫筆/橡皮擦狀態
                ea = 0;      // 強制切換到橡皮擦模式
                
                // 遍歷路徑陣列，把點過的地方都擦掉
                for (var h = 0; h < wx.length; h++) {
                    df(wx[h], wy[h], 0); // 呼叫繪圖函式執行擦除
                }
                
                ea = we;     // 還原畫筆狀態
                wz = 0;      // 標記路徑已消失
                psh();       // 擦除完後存一個檔
            }
        };
        function loadFile(ev) {
            let file = ev.target.files[0];
            let reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onloadend = (e) => {
                let image = new Image(); image.src = e.target.result;
                image.onload = () => {
                    sx = image.width / q; sy = image.height / q;
                    a1.width = image.width; a1.height = image.height;
                    ctx.drawImage(image, 0, 0); psh();
                }
            }
        }
    </script>
</body>
</html>